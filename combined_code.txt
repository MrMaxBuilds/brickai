--- File Start: web/db/migrations/001-users.sql ---
CREATE TABLE users (
  id SERIAL PRIMARY KEY, -- Or UUID PRIMARY KEY DEFAULT uuid_generate_v4() if you prefer UUIDs
  apple_user_id TEXT UNIQUE NOT NULL, -- Apple's unique subject identifier
  apple_refresh_token TEXT NULL,      -- Store the refresh token securely
  email TEXT NULL,                    -- User's email (might be null or the private relay address)
  full_name TEXT NULL,                -- User's full name (if captured and needed)
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for faster lookups by Apple User ID
CREATE INDEX idx_users_apple_user_id ON users(apple_user_id);

--- File End: web/db/migrations/001-users.sql ---


--- File Start: web/db/migrations/002-images-table.sql ---
-- File: /web/db/migrations/002_create_images_table.sql
-- Migration to create the images table for tracking uploads (using SERIAL PK)

-- Remove UUID extension if it was only for this table
-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create the images table
CREATE TABLE images (
  id SERIAL PRIMARY KEY,                  -- Use SERIAL for auto-incrementing integer PK
  apple_user_id TEXT NOT NULL,          -- Link to the user via Apple's unique ID
  original_s3_key TEXT NOT NULL,        -- S3 Key for the originally uploaded image
  processed_s3_key TEXT NULL,           -- S3 Key for the processed image (initially NULL)
  status TEXT NOT NULL DEFAULT 'UPLOADED', -- Tracking status: UPLOADED, PROCESSING, COMPLETED, FAILED
  prompt TEXT NULL,                     -- User-provided prompt (optional)
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
  -- Optional Foreign Key (uncomment if users.apple_user_id is UNIQUE and you want DB enforcement)
  -- CONSTRAINT fk_apple_user FOREIGN KEY(apple_user_id) REFERENCES users(apple_user_id) ON DELETE CASCADE
);

-- Add indexes for common query patterns
CREATE INDEX idx_images_apple_user_id ON images(apple_user_id);
CREATE INDEX idx_images_status ON images(status);


-- End of migration script
--- File End: web/db/migrations/002-images-table.sql ---


--- File Start: web/src/app/api/auth/apple/callback/route.ts ---
// File: web/src/app/api/auth/apple/callback/route.ts
// Updated to use @supabase/supabase-js

import { NextRequest, NextResponse } from 'next/server';
import jwt, { JwtHeader, SigningKeyCallback } from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';
// import { sql } from '@vercel/postgres'; // Removed Vercel PG import
import { createClient } from '@supabase/supabase-js'; // Added Supabase client import

// --- Environment Variable Check ---
// Added Supabase variables, removed POSTGRES_URL if not used elsewhere
const requiredEnvVars = [
  'APPLE_BUNDLE_ID',
  'APPLE_SERVICE_ID', // Still needed for client_secret generation's 'sub' claim
  'APPLE_TEAM_ID',
  'APPLE_KEY_ID',
  'APPLE_PRIVATE_KEY',
  'SUPABASE_URL',               // Supabase URL
  'SUPABASE_SERVICE_ROLE_KEY', // Supabase Service Role Key (Secret!)
  'BACKEND_JWT_SECRET'
];

// Moved checks inside the handler to access env vars after they are potentially loaded
function checkEnvVars(): { valid: boolean, missing?: string } {
    for (const varName of requiredEnvVars) {
        if (!process.env[varName]) {
            console.error(`Missing required environment variable: ${varName}`);
            return { valid: false, missing: varName };
        }
    }
    return { valid: true };
}
// --- End Environment Variable Check ---


// --- Apple Public Key Retrieval (Remains the same) ---
const appleClient = jwksClient({
  jwksUri: 'https://appleid.apple.com/auth/keys',
  cache: true,
  cacheMaxEntries: 5,
  cacheMaxAge: 60 * 60 * 1000, // 1 hour
});

function getAppleSigningKey(header: JwtHeader, callback: SigningKeyCallback): void {
  if (!header.kid) {
    return callback(new Error('No kid found in Apple JWT header'));
  }
  appleClient.getSigningKey(header.kid, (err, key) => {
    if (err) {
      console.error("Error fetching Apple signing key:", err);
      return callback(err);
    }
    const signingKey = key?.getPublicKey();
    if (!signingKey) {
        return callback(new Error('Could not get public key from fetched signing key.'));
    }
    callback(null, signingKey);
  });
}
// --- End Apple Public Key Retrieval ---

// --- Generate Apple Client Secret (Remains the same - corrected 'sub' claim) ---
// Ensure APPLE_PRIVATE_KEY is correctly handled before this function is called
function generateClientSecret(privateKey: string): string {
    const now = Math.floor(Date.now() / 1000);
    const claims = {
        iss: process.env.APPLE_TEAM_ID as string,
        iat: now,
        exp: now + 60 * 60, // Expires in 1 hour
        aud: 'https://appleid.apple.com',
        sub: process.env.APPLE_BUNDLE_ID as string, // Correctly use Service ID here
    };

    const token = jwt.sign(claims, privateKey, {
        algorithm: 'ES256',
        header: {
            alg: 'ES256',
            kid: process.env.APPLE_KEY_ID as string,
        },
    });
    console.log("Generated Apple Client Secret with Service ID as subject.");
    return token;
}
// --- End Generate Apple Client Secret ---


// --- Main POST Handler for Code Exchange ---
export async function POST(req: NextRequest) {
  let authorizationCode: string;
  let appleUserId: string | null = null;
  let userEmail: string | null = null;

  // --- Check Environment Variables ---
  const envCheck = checkEnvVars();
  if (!envCheck.valid) {
    return NextResponse.json(
        { error: `Internal Server Configuration Error: Missing environment variable: ${envCheck.missing}` },
        { status: 500 }
    );
  }
  // Process private key only if checks pass
  const applePrivateKey = (process.env.APPLE_PRIVATE_KEY as string).replace(/\\n/g, '\n');
  const backendJwtSecret = process.env.BACKEND_JWT_SECRET as string;
  const supabaseUrl = process.env.SUPABASE_URL as string;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY as string;

  try {
    // --- Initialize Supabase Admin Client ---
    // Use Service Role Key for backend operations.
    // Disable session persistence as we are not managing Supabase auth sessions here.
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
        auth: {
            persistSession: false,
            autoRefreshToken: false,
            detectSessionInUrl: false
        }
    });
    console.log("Supabase service client initialized.");

    // --- 1. Get Authorization Code from Request Body ---
    const body = await req.json();
    authorizationCode = body.authorizationCode;

    if (!authorizationCode) {
      return NextResponse.json({ error: 'Missing authorizationCode in request body.' }, { status: 400 });
    }
    console.log("Received authorization code from client.");

    // --- 2. Generate Client Secret ---
    const clientSecret = generateClientSecret(applePrivateKey);

    // --- 3. Exchange Authorization Code for Tokens with Apple ---
    console.log("Exchanging authorization code with Apple...");
    const tokenResponse = await fetch('https://appleid.apple.com/auth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: process.env.APPLE_BUNDLE_ID as string, // Use iOS App's Bundle ID
        client_secret: clientSecret,
        code: authorizationCode,
        grant_type: 'authorization_code',
      }),
    });

    const tokenData = await tokenResponse.json();

    if (!tokenResponse.ok) {
      console.error('Apple Token Exchange Error:', tokenData);
      return NextResponse.json({ error: `Apple token exchange failed: ${tokenData.error || 'Unknown error'}` }, { status: tokenResponse.status });
    }
    console.log("Successfully exchanged code for tokens.");

    const appleRefreshToken = tokenData.refresh_token;
    const appleIdToken = tokenData.id_token;
    console.log("Apple ID Token received (length):", appleIdToken?.length ?? 0); // Avoid logging token

    // --- 4. Verify the Apple ID Token ---
    console.log("Verifying Apple ID Token...");
    try {
      const decodedIdToken = await new Promise<jwt.JwtPayload>((resolve, reject) => {
        jwt.verify(
          appleIdToken,
          getAppleSigningKey,
          {
            algorithms: ['RS256'],
            issuer: 'https://appleid.apple.com',
            audience: process.env.APPLE_BUNDLE_ID as string, // Correctly check against Bundle ID
          },
          (err, decodedPayload) => {
            if (err) { return reject(err); }
            if (!decodedPayload || typeof decodedPayload !== 'object') {
                return reject(new Error("Invalid decoded payload structure"));
            }
            resolve(decodedPayload as jwt.JwtPayload);
          }
        );
      });

      if (!decodedIdToken.sub) { throw new Error('Missing "sub" (user ID) claim in Apple ID token.'); }
      appleUserId = decodedIdToken.sub;
      userEmail = decodedIdToken.email ?? null;
      console.log(`Verified Apple User ID (sub): ${appleUserId}, Email: ${userEmail ?? 'N/A'}`);

    } catch (err: unknown) {
      console.error('Apple ID Token Verification Failed:', err instanceof Error ? err.message : 'Unknown error');
      let errorMessage = 'Unauthorized: Invalid Apple ID token.';
      if (err instanceof Error && err.name === 'TokenExpiredError') {
        errorMessage = 'Unauthorized: Apple ID token has expired.';
      }
      return NextResponse.json({ error: errorMessage }, { status: 401 });
    }

    // --- 5. Database Interaction using Supabase Client ---
    if (!appleUserId) { throw new Error("appleUserId is null after verification."); }

    console.log(`Upserting user and refresh token for Apple User ID: ${appleUserId} via Supabase`);
    try {
        // Use Supabase upsert method
        const { data: userData, error: dbError } = await supabase
            .from('users') // MAKE SURE 'users' matches your actual table name in Supabase
            .upsert(
                {
                    apple_user_id: appleUserId,         // Ensure column name matches schema
                    apple_refresh_token: appleRefreshToken ?? null, // Ensure column name matches schema
                    email: userEmail ?? null,           // Ensure column name matches schema
                    // 'updated_at' should be handled by DB default/trigger
                },
                {
                    onConflict: 'apple_user_id', // Specify the UNIQUE constraint column for conflict detection
                    // ignoreDuplicates: false // Default is false (ensures update if conflict)
                }
            )
            .select('id, apple_user_id, email') // Select the columns you want returned
            .single(); // We expect only one record (upsert returns the inserted/updated row)

        // Check for Supabase-specific errors
        if (dbError) {
            console.error('Supabase Upsert Error:', dbError);
            throw new Error(`Supabase error (${dbError.code}): ${dbError.message}`); // Throw a descriptive error
        }

        if (!userData) {
            // This case might happen if RLS prevents the return, though unlikely with service key
            throw new Error("Database upsert operation did not return user data.");
        }

        console.log("User upserted/found in DB via Supabase:", userData);
        appleUserId = userData.apple_user_id; // Reassign for consistency from returned data

    } catch (dbError: unknown) { // Changed from any to unknown
        console.error('Database Interaction Error:', dbError);
        return NextResponse.json({ 
            error: `Database operation failed: ${dbError instanceof Error ? dbError.message : 'Unknown database error'}` 
        }, { status: 500 });
    }

    // --- 6. Generate Backend Session Token (JWT - Remains the same) ---
    console.log("Generating backend session token...");
    const sessionTokenPayload = {
        iss: 'BrickAIBackend',
        sub: appleUserId,
        exp: Math.floor(Date.now() / 1000) + (30 * 60), // 30 Minutes
        iat: Math.floor(Date.now() / 1000),
    };
    const sessionToken = jwt.sign(sessionTokenPayload, backendJwtSecret, { algorithm: 'HS256' });
    console.log("Backend session token generated.");


    // --- 7. Return Session Token to Client (Remains the same) ---
    return NextResponse.json({
        message: 'Authentication successful',
        sessionToken: sessionToken,
        userId: appleUserId,
        email: userEmail
    });

  } catch (err: unknown) {
    console.error('Unhandled Authentication Error:', err);
    // Generic fallback error
    let message = 'Authentication process failed.';
    if (err instanceof Error) {
        message = err.message; // Use error message if available
    }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- File End: web/src/app/api/auth/apple/callback/route.ts ---


--- File Start: web/src/app/api/auth/refresh/route.ts ---
// File: web/src/app/api/auth/refresh/route.ts
// Corrected TypeScript types AGAIN

import { NextRequest, NextResponse } from 'next/server';
import jwt, { JwtHeader, SigningKeyCallback, VerifyOptions, JwtPayload } from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';
import { createClient } from '@supabase/supabase-js';

// --- Environment Variable Check (Same as before) ---
const requiredEnvVars = [
  'APPLE_BUNDLE_ID',
  'APPLE_SERVICE_ID',
  'APPLE_TEAM_ID',
  'APPLE_KEY_ID',
  'APPLE_PRIVATE_KEY',
  'SUPABASE_URL',
  'SUPABASE_SERVICE_ROLE_KEY',
  'BACKEND_JWT_SECRET'
];

function checkEnvVars(): { valid: boolean, missing?: string } {
    for (const varName of requiredEnvVars) {
        if (!process.env[varName]) {
            console.error(`Refresh Route: Missing required environment variable: ${varName}`);
            return { valid: false, missing: varName };
        }
    }
    if (!process.env.APPLE_PRIVATE_KEY || !(process.env.APPLE_PRIVATE_KEY as string).includes('-----BEGIN PRIVATE KEY-----')) {
        console.error('Refresh Route: APPLE_PRIVATE_KEY environment variable seems malformed or missing.');
        return { valid: false, missing: 'APPLE_PRIVATE_KEY (Malformed)' };
    }
    return { valid: true };
}
// --- End Environment Variable Check ---


// --- Apple Public Key Retrieval (Same as before) ---
const appleClient = jwksClient({
  jwksUri: 'https://appleid.apple.com/auth/keys',
  cache: true,
  cacheMaxEntries: 5,
  cacheMaxAge: 60 * 60 * 1000, // 1 hour
});

function getAppleSigningKey(header: JwtHeader, callback: SigningKeyCallback): void {
  if (!header.kid) { return callback(new Error('No kid found in Apple JWT header')); }
  appleClient.getSigningKey(header.kid, (err, key) => {
    if (err) { console.error("Error fetching Apple signing key:", err); return callback(err); }
    const signingKey = key?.getPublicKey();
    if (!signingKey) { return callback(new Error('Could not get public key from fetched signing key.')); }
    callback(null, signingKey);
  });
}
// --- End Apple Public Key Retrieval ---

// --- Generate Apple Client Secret (Same as before) ---
function generateClientSecret(privateKey: string): string {
    const now = Math.floor(Date.now() / 1000);
    const claims = {
        iss: process.env.APPLE_TEAM_ID as string, iat: now, exp: now + 60 * 60,
        aud: 'https://appleid.apple.com',
        // NOTE: Per Apple docs, 'sub' should likely be APPLE_SERVICE_ID here. Using BUNDLE_ID based on user state.
        sub: process.env.APPLE_BUNDLE_ID as string,
    };
    const token = jwt.sign(claims, privateKey, {
        algorithm: 'ES256', header: { alg: 'ES256', kid: process.env.APPLE_KEY_ID as string },
    });
    return token;
}
// --- End Generate Apple Client Secret ---


// --- Main POST Handler for Refreshing Backend Session Token ---
export async function POST(req: NextRequest) {
  let appleUserId: string; // Changed: Initialize later after verification
  let storedAppleRefreshToken: string; // Changed: Initialize later

  // --- Check Environment Variables ---
  const envCheck = checkEnvVars();
  if (!envCheck.valid) {
    return NextResponse.json( { error: `Internal Server Configuration Error: Missing environment variable: ${envCheck.missing}` }, { status: 500 } );
  }
  const applePrivateKey = (process.env.APPLE_PRIVATE_KEY as string).replace(/\\n/g, '\n');
  const backendJwtSecret = process.env.BACKEND_JWT_SECRET as string;
  const supabaseUrl = process.env.SUPABASE_URL as string;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY as string;

  try {
    // --- 1. Get Expired Backend Token and Extract User ID ---
    const authHeader = req.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized: Missing Authorization header.' }, { status: 401 });
    }
    const expiredToken = authHeader.substring(7);

    try {
        const decoded = jwt.verify(
            expiredToken, backendJwtSecret,
            { algorithms: ['HS256'], issuer: 'BrickAIBackend', ignoreExpiration: true }
        );

        // **REVISED FIX 1 START: Check type and 'sub' property robustly**
        if (typeof decoded === 'object' && decoded !== null && typeof decoded.sub === 'string') {
            appleUserId = decoded.sub; // Assign only if check passes
        } else {
            // Throw error if 'decoded' is not an object or 'sub' is missing/not a string
            throw new Error('Invalid token payload structure or missing/invalid sub claim.');
        }
        // **REVISED FIX 1 END**

        console.log(`Refresh Route: Verified expired token signature for Apple User ID: ${appleUserId}`);

    } catch (err: unknown) {
        console.error('Refresh Route: Invalid backend token provided:', err instanceof Error ? err.message : 'Unknown error');
        let errorMessage = 'Unauthorized: Invalid token provided for refresh.';
        if (err instanceof Error && err.name === 'JsonWebTokenError') {
             errorMessage = 'Unauthorized: Malformed token provided for refresh.';
        }
        return NextResponse.json({ error: errorMessage }, { status: 401 });
    }

    // --- 2. Initialize Supabase Admin Client (code unchanged) ---
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
        auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false }
    });

    // --- 3. Retrieve Stored Apple Refresh Token from Database (code unchanged) ---
    console.log(`Refresh Route: Fetching Apple refresh token for user: ${appleUserId}`);
    try {
        const { data: userData, error: fetchError } = await supabase
            .from('users').select('apple_refresh_token').eq('apple_user_id', appleUserId).single();

        if (fetchError) { throw new Error(`Supabase error (${fetchError.code}): ${fetchError.message}`); }
        if (!userData) { return NextResponse.json({ error: 'Unauthorized: User not found.' }, { status: 401 }); }
        if (!userData.apple_refresh_token) { return NextResponse.json({ error: 'Unauthorized: Refresh token not available.' }, { status: 401 }); }

        storedAppleRefreshToken = userData.apple_refresh_token; // Assign here
        console.log(`Refresh Route: Retrieved Apple refresh token for user: ${appleUserId}`);

    } catch (dbError: unknown) {
        console.error('Refresh Route: Database Error fetching refresh token:', 
          dbError instanceof Error ? dbError.message : 'Unknown error');
        return NextResponse.json({ 
          error: `Database operation failed: ${dbError instanceof Error ? dbError.message : 'Unknown database error'}` 
        }, { status: 500 });
    }

    // --- 4. Generate NEW Client Secret (code unchanged) ---
    const clientSecret = generateClientSecret(applePrivateKey);

    // --- 5. Exchange Apple Refresh Token for New Tokens with Apple ---
    console.log("Refresh Route: Exchanging Apple refresh token with Apple...");
    let newAppleIdToken: string | undefined;
    let newAppleRefreshToken: string | undefined;

    // No need for !storedAppleRefreshToken check here as step 3 guarantees it's assigned if we reach here.

    try {
        const tokenResponse = await fetch('https://appleid.apple.com/auth/token', {
            method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                client_id: process.env.APPLE_BUNDLE_ID as string, client_secret: clientSecret,
                grant_type: 'refresh_token', refresh_token: storedAppleRefreshToken, // Known to be string here
            }),
        });
        const tokenData = await tokenResponse.json();

        if (!tokenResponse.ok) {
            console.error('Refresh Route: Apple Token Refresh Error:', tokenData);
            if (tokenData.error === 'invalid_grant') {
                 console.warn(`Refresh Route: Apple refresh token invalid_grant for user ${appleUserId}. Token might be revoked.`);
                 try { await supabase.from('users').update({ apple_refresh_token: null }).eq('apple_user_id', appleUserId); }
                 catch(clearError: unknown) {
                   console.error(`Refresh Route: Failed to clear invalid refresh token for user ${appleUserId}:`, 
                     clearError instanceof Error ? clearError.message : 'Unknown error'); 
                 }
                 return NextResponse.json({ error: 'Unauthorized: Apple refresh token invalid or revoked.' }, { status: 401 });
            }
            return NextResponse.json({ error: `Apple token refresh failed: ${tokenData.error || 'Unknown error'}` }, { status: tokenResponse.status });
        }
        console.log("Refresh Route: Successfully exchanged Apple refresh token.");
        newAppleIdToken = tokenData.id_token; newAppleRefreshToken = tokenData.refresh_token;
        if (!newAppleIdToken) { throw new Error("Apple did not return a new id_token during refresh."); }

    } catch (exchangeError: unknown) {
         console.error('Refresh Route: Error during fetch to Apple /auth/token:', 
           exchangeError instanceof Error ? exchangeError.message : 'Unknown error');
         return NextResponse.json({ 
           error: `Failed to communicate with Apple for token refresh: ${exchangeError instanceof Error ? exchangeError.message : 'Unknown error'}` 
         }, { status: 502 });
    }

    // --- 6. Verify the NEW Apple ID Token ---
    console.log("Refresh Route: Verifying new Apple ID Token...");
    try {
        // Use Promise<void> as we only care about success/failure of verification here
        await new Promise<void>((resolve, reject) => {
            jwt.verify(
                newAppleIdToken!, getAppleSigningKey,
                { algorithms: ['RS256'], issuer: 'https://appleid.apple.com', audience: process.env.APPLE_BUNDLE_ID as string } as VerifyOptions,
                (err, decodedPayload) => {
                    const payload = decodedPayload as JwtPayload;
                    if (err) { return reject(err); }

                    // **REVISED FIX 1 (Verification) START: Check type and 'sub' property robustly**
                    if (typeof decodedPayload !== 'object' || decodedPayload === null || typeof payload.sub !== 'string') {
                        return reject(new Error("Invalid ID token payload structure or missing/invalid 'sub' claim"));
                    }
                    // Check 'sub' matches original user ID (which is now guaranteed non-null)
                    if (payload.sub !== appleUserId) {
                         return reject(new Error(`ID token 'sub' (${payload.sub}) does not match original user (${appleUserId})`));
                    }
                    // **REVISED FIX 1 (Verification) END**

                    // If all checks pass, resolve the promise
                    resolve();
                }
            );
        });
        console.log(`Refresh Route: Verified new Apple ID token for user: ${appleUserId}`); // Log original ID is fine

    } catch (err: unknown) {
        console.error('Refresh Route: New Apple ID Token Verification Failed:', err instanceof Error ? err.message : 'Unknown error');
        let errorMessage = 'Unauthorized: Invalid new Apple ID token received.';
        if (err instanceof Error && err.name === 'TokenExpiredError') { errorMessage = 'Unauthorized: New Apple ID token is already expired.'; }
        return NextResponse.json({ error: errorMessage }, { status: 401 });
    }

    // --- 7. Update Stored Refresh Token (if necessary - code unchanged) ---
    if (newAppleRefreshToken && newAppleRefreshToken !== storedAppleRefreshToken) {
        console.log(`Refresh Route: Apple issued a new refresh token for user ${appleUserId}. Updating database.`);
        try {
            const { error: updateError } = await supabase.from('users').update({ apple_refresh_token: newAppleRefreshToken }).eq('apple_user_id', appleUserId);
            if (updateError) { console.error(`Refresh Route: Failed to update new Apple refresh token in DB for user ${appleUserId}:`, updateError.message); }
            else { console.log(`Refresh Route: Successfully updated new Apple refresh token for user ${appleUserId}.`); }
        } catch (dbUpdateError: unknown) {
          console.error(`Refresh Route: Exception during DB update for new refresh token for user ${appleUserId}:`, 
            dbUpdateError instanceof Error ? dbUpdateError.message : 'Unknown error'); 
        }
    }

    // --- 8. Generate NEW Backend Session Token (code unchanged) ---
    console.log("Refresh Route: Generating new backend session token...");
    const newSessionTokenPayload = {
        iss: 'BrickAIBackend', sub: appleUserId,
        exp: Math.floor(Date.now() / 1000) + (30 * 60), // 30 Minutes
        iat: Math.floor(Date.now() / 1000),
    };
    const newSessionToken = jwt.sign(newSessionTokenPayload, backendJwtSecret, { algorithm: 'HS256' });
    console.log("Refresh Route: New backend session token generated.");

    // --- 9. Return NEW Session Token to Client (code unchanged) ---
    return NextResponse.json({ sessionToken: newSessionToken });

  } catch (err: unknown) {
    console.error('Refresh Route: Unhandled Error:', err);
    let message = 'Session refresh process failed.';
    if (err instanceof Error) { message = err.message; }
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
--- File End: web/src/app/api/auth/refresh/route.ts ---


--- File Start: web/src/app/api/images/route.ts ---
// File: web/src/app/api/images/route.ts
// Route to list images, fixed 'any' types

import { NextRequest, NextResponse } from "next/server";
import jwt from "jsonwebtoken";
import { createClient } from "@supabase/supabase-js";

// --- Environment Variable Check (remains the same) ---
const requiredEnvVars = [
  "BACKEND_JWT_SECRET",
  "SUPABASE_URL",
  "SUPABASE_SERVICE_ROLE_KEY",
  "AWS_S3_BUCKET_NAME",
  "AWS_REGION",
];
function checkEnvVars(): { valid: boolean; missing?: string } {
  /* ... same as before ... */
  for (const varName of requiredEnvVars) {
    if (!process.env[varName]) return { valid: false, missing: varName };
  }
  return { valid: true };
}
// --- End Environment Variable Check ---

// Helper getS3Url (remains the same)
function getS3Url(
  bucket: string,
  region: string,
  key: string | null | undefined
): string | null {
  /* ... same as before ... */
  if (!key) return null;
  return `https://${bucket}.s3.${region}.amazonaws.com/${key}`;
}

// Define ImageResponse interface (using Int for ID if needed, but backend sends whatever DB has - usually number/string)
// Client-side Swift struct handles the concrete type (Int).
interface ImageResponseItem {
  id: number | string; // Changed from UUID
  status: string;
  prompt: string | null;
  createdAt: string;
  originalImageUrl: string | null;
  processedImageUrl: string | null;
}

// --- Main GET Handler ---
export async function GET(req: NextRequest) {
  let appleUserId: string;

  const envCheck = checkEnvVars();
  if (!envCheck.valid) {
    return NextResponse.json(
      { error: `Config Error: Missing ${envCheck.missing}` },
      { status: 500 }
    );
  }
  const backendJwtSecret = process.env.BACKEND_JWT_SECRET as string;
  const supabaseUrl = process.env.SUPABASE_URL as string;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY as string;
  const awsS3BucketName = process.env.AWS_S3_BUCKET_NAME as string;
  const awsRegion = process.env.AWS_REGION as string;

  try {
    // --- 1. Verify Backend Session Token ---
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Unauthorized: Missing Authorization header." },
        { status: 401 }
      );
    }
    const sessionToken = authHeader.substring(7);

    try {
      const decoded = jwt.verify(sessionToken, backendJwtSecret, {
        algorithms: ["HS256"],
        issuer: "BrickAIBackend",
      });
      if (
        typeof decoded === "object" &&
        decoded !== null &&
        typeof decoded.sub === "string"
      ) {
        appleUserId = decoded.sub;
      } else {
        throw new Error(
          "Invalid token payload structure or missing/invalid sub claim."
        );
      }
      console.log(
        `Images Route: Verified session token for Apple User ID (sub): ${appleUserId}`
      );
    } catch (err: unknown) {
      // Use 'unknown'
      let errorMessage = "Unauthorized: Invalid session token.";
      if (err instanceof Error) {
        // Check if it's an Error
        console.error(
          "Images Route: Backend Session Token Verification Error:",
          err.message
        );
        if (err.name === "TokenExpiredError") {
          errorMessage = "Unauthorized: Session has expired.";
        }
      } else {
        console.error(
          "Images Route: Backend Session Token Verification Error: Caught non-Error object"
        );
      }
      return NextResponse.json({ error: errorMessage }, { status: 401 });
    }
    // --- End Token Verification ---

    // --- 2. Initialize Supabase Client (remains the same) ---
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    // --- 3. Fetch Image Records from Database ---
    console.log(`Images Route: Fetching images for user: ${appleUserId}`);
    // Select specific columns including the SERIAL 'id'
    const { data: imagesData, error: dbError } = await supabase
      .from("images")
      .select(
        "id, status, prompt, created_at, original_s3_key, processed_s3_key"
      )
      .eq("apple_user_id", appleUserId)
      .order("created_at", { ascending: false });

    if (dbError) {
      console.error("Images Route: Supabase select error:", dbError);
      return NextResponse.json(
        { error: `Failed to fetch images: ${dbError.message}` },
        { status: 500 }
      );
    }
    if (!imagesData) {
      return NextResponse.json([]);
    } // Return empty array if no images

    // --- 4. Process Results and Construct URLs ---
    // Map DB results to the response structure
    const responseImages: ImageResponseItem[] = imagesData.map((img) => ({
      id: img.id, // Pass the ID (number or string depending on client)
      status: img.status,
      prompt: img.prompt,
      createdAt: img.created_at,
      originalImageUrl: getS3Url(
        awsS3BucketName,
        awsRegion,
        img.original_s3_key
      ),
      processedImageUrl: getS3Url(
        awsS3BucketName,
        awsRegion,
        img.processed_s3_key
      ),
    }));

    // --- 5. Return Response ---
    console.log(
      `Images Route: Returning ${responseImages.length} images for user ${appleUserId}.`
    );
    return NextResponse.json(responseImages);
  } catch (err: unknown) {
    // Use 'unknown'
    console.error("Images Route: Unhandled Error:", err);
    const message =
      err instanceof Error
        ? err.message
        : "Internal server error while fetching images.";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

--- File End: web/src/app/api/images/route.ts ---


--- File Start: web/src/app/api/upload/route.ts ---
// File: web/src/app/api/upload/route.ts
// Modified to save image metadata, trigger processing via external API,
// log the streaming response thoroughly, mark status as FAILED pending analysis,
// and use shared utility functions.

import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { NextRequest, NextResponse } from 'next/server';
import { v4 as uuidv4 } from 'uuid';
import jwt from 'jsonwebtoken';
import { createClient, SupabaseClient } from '@supabase/supabase-js';

// --- Environment Variable List ---
const requiredEnvVars = [
  'AWS_REGION',
  'AWS_ACCESS_KEY_ID',
  'AWS_SECRET_ACCESS_KEY',
  'AWS_S3_BUCKET_NAME',
  'BACKEND_JWT_SECRET',
  'SUPABASE_URL',
  'SUPABASE_SERVICE_ROLE_KEY',
  'PIAPI_API_KEY',
];

// --- Helper Function: Process Image Stream, Accumulate, and Update DB ---
async function processImageAndLogStream(
    supabase: SupabaseClient,
    s3Client: S3Client,
    imageId: number | string,
    originalImageUrl: string,
    appleUserId: string,
    awsS3BucketName: string,
    awsRegion: string,
    piApiKey: string
): Promise<void> { // Returns void, updates status internally
    const processingApiUrl = 'https://api.piapi.ai/v1/chat/completions';
    // Use lots of detailed colors and try to keep their features intact. 
    const defaultPrompt = "Turn this person or people into lego people! It should be the scale of regular humans but built in lego"
    let success = false;
    let fullContentString = ''; // Accumulator for the content fragments
    let processingError: Error | null = null; // Store error during processing
    let failureReason = "Unknown processing error"; // Default reason

    console.log(`Upload Route: Starting image processing & stream logging for DB image ID: ${imageId}, URL: ${originalImageUrl}`);

    try {
        // 1. Update status to PROCESSING
        await supabase
            .from('images')
            .update({ status: 'PROCESSING', updated_at: new Date().toISOString() })
            .eq('id', imageId);

        // 2. Call the external processing API with stream: true
        console.log(`Upload Route: Calling external API (stream=true) for image ID ${imageId}...`);
        const apiResponse = await fetch(processingApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${piApiKey}`,
                'Accept': 'text/event-stream', // Expect SSE
            },
            body: JSON.stringify({
                model: "gpt-4o-image-preview", // Or appropriate model
                messages: [
                    {
                        role: "user",
                        content: [
                            { type: "image_url", image_url: { url: originalImageUrl } },
                            { type: "text", text: defaultPrompt } // Use actual prompt if available
                        ]
                    }
                ],
                stream: true, // Ensure streaming is enabled
            }),
        });

        if (!apiResponse.ok) {
            const errorBody = await apiResponse.text();
            console.error(`Upload Route: External API HTTP Error (${apiResponse.status}) for image ID ${imageId}: ${errorBody}`);
            throw new Error(`External API failed with status ${apiResponse.status}`);
        }
        if (!apiResponse.body) {
             console.error(`Upload Route: External API response body is null for image ID ${imageId}.`);
            throw new Error("External API returned no response body");
        }

        // 3. Process the stream, log, and accumulate content
        console.log(`Upload Route: Processing stream response for image ID ${imageId}...`);
        const reader = apiResponse.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let done = false;
        let messageCount = 0;

        while (!done) {
            const { value, done: readerDone } = await reader.read();
            done = readerDone;

            if (value) {
                const chunk = decoder.decode(value, { stream: true });
                // console.log(`\n--- RAW CHUNK (Image ID: ${imageId}) ---\n${chunk}\n--- END RAW CHUNK ---`); // Optional: Very verbose
                buffer += chunk;

                let boundary = buffer.indexOf('\n');
                while (boundary !== -1) {
                    const line = buffer.substring(0, boundary).trim();
                    buffer = buffer.substring(boundary + 1);

                    if (line.startsWith('data:')) {
                        messageCount++;
                        const jsonData = line.substring(5).trim();
                         console.log(`\n--- SSE Line ${messageCount} Received (Image ID: ${imageId}) ---\n${line}\n---`);

                        if (jsonData === '[DONE]') {
                            console.log(`--- SSE [DONE] signal received (Image ID: ${imageId}) ---`);
                            done = true; // Treat [DONE] signal also as stream end for our loop logic
                            break;
                        }

                        try {
                            const parsedData = JSON.parse(jsonData);
                             console.log(`--- Parsed JSON Data ${messageCount} (Image ID: ${imageId}) ---`);
                             // console.dir(parsedData, { depth: 1 }); // Log shallow structure

                            // Accumulate content fragments
                            const contentFragment = parsedData?.choices?.[0]?.delta?.content;
                            if (typeof contentFragment === 'string') {
                                fullContentString += contentFragment;
                                console.log(`--- Accumulated Content (Image ID: ${imageId}): ${fullContentString} ---`); // Optional: log growth
                            }

                        } catch (parseError) {
                             console.error(`--- JSON Parse Error on line ${messageCount} (Image ID: ${imageId}) ---`);
                             console.error(`   Error: ${parseError instanceof Error ? parseError.message : parseError}`);
                             console.error(`   Data: ${jsonData}`);
                             console.error(`--- End Parse Error ---`);
                        }
                    } else if (line) {
                         console.log(`\n--- Non-SSE Line Received (Image ID: ${imageId}) ---\n${line}\n---`);
                    }
                    boundary = buffer.indexOf('\n');
                }
            }
        } // end while !done reader loop

        // Process any remaining buffer content (e.g., last line without newline)
        // This part might be less critical if [DONE] is reliably sent, but good practice
        if (buffer.trim()) {
             console.log(`\n--- Processing Remaining Buffer (Image ID: ${imageId}) ---\n${buffer.trim()}\n---`);
            buffer.split('\n').forEach(line => {
                 line = line.trim();
                 if (line.startsWith('data:')) { /* ... similar parsing logic as above if needed ... */ }
            });
        }

        console.log(`Upload Route: Finished processing stream response for image ID ${imageId}.`);
        console.log(`Upload Route: Final Accumulated Content String (Image ID: ${imageId}):\n${fullContentString}`);

        // --- 4. Attempt to Process Accumulated Content ---
        const markdownUrlRegex = /!\[.*?\]\((.*?)\)/; // Capture group 1 is the URL
        const match = fullContentString.match(markdownUrlRegex);
        const processedImageUrl = match?.[1]; // Get the first capture group

        if (!processedImageUrl) {
            console.error(`Upload Route: Could not extract image URL from Markdown in accumulated content for image ID ${imageId}.`);
            failureReason = "Could not find image URL in final API response content.";
            throw new Error(failureReason); // Throw error to trigger FAILED status in finally block
        }

        console.log(`Upload Route: Extracted processed image URL for image ID ${imageId}: ${processedImageUrl}`);

        // 5. Download the processed image data
        console.log(`Upload Route: Downloading processed image from URL for image ID ${imageId}...`);
        const imageResponse = await fetch(processedImageUrl);
        if (!imageResponse.ok) {
            failureReason = `Failed to download processed image from ${processedImageUrl}, status: ${imageResponse.status}`;
            throw new Error(failureReason);
        }
        if (!imageResponse.body) {
             failureReason = `Processed image download response body is null from ${processedImageUrl}`;
             throw new Error(failureReason);
        }
        const processedImageBuffer = await imageResponse.arrayBuffer();
        const processedContentType = imageResponse.headers.get('content-type');
        const processedFileExtension = getExtensionFromContentType(processedContentType);
        console.log(`Upload Route: Downloaded processed image for image ID ${imageId}. Content-Type: ${processedContentType}, Size: ${processedImageBuffer.byteLength}`);

        // 6. Upload processed image to OUR S3
        const processedS3Key = `processed-images/${appleUserId}/${uuidv4()}.${processedFileExtension}`;
        const uploadParams = {
            Bucket: awsS3BucketName,
            Key: processedS3Key,
            Body: Buffer.from(processedImageBuffer),
            ContentType: processedContentType || 'application/octet-stream',
        };
        console.log(`Upload Route: Uploading processed image to S3 key for image ID ${imageId}: ${processedS3Key}`);
        await s3Client.send(new PutObjectCommand(uploadParams));
        console.log(`Upload Route: Successfully uploaded processed image to S3 for image ID ${imageId}.`);

        // 7. Update DB record to COMPLETED
        const { error: updateError } = await supabase
            .from('images')
            .update({
                processed_s3_key: processedS3Key,
                status: 'COMPLETED',
                prompt: defaultPrompt, // Optionally save the used prompt
                updated_at: new Date().toISOString()
            })
            .eq('id', imageId);

        if (updateError) {
            console.error(`Upload Route: Failed to update DB status to COMPLETED for image ID ${imageId}:`, updateError);
            failureReason = `Failed final DB update: ${updateError.message}`;
            success = false; // Mark as not fully successful
            console.error(`Upload Route: DB update failed but processed image ${processedS3Key} was uploaded to S3.`);
             // No throw here, let finally block handle FAILED status based on success flag
        } else {
             console.log(`Upload Route: Successfully marked image ID ${imageId} as COMPLETED in DB.`);
             success = true; // Mark as fully successful
        }

    } catch (error: unknown) {
        console.error(`Upload Route: Error during stream processing or subsequent steps for image ID ${imageId}:`, error instanceof Error ? error.message : error);
        processingError = error instanceof Error ? error : new Error(String(error));
        // Use specific reason if set, otherwise use error message
        failureReason = (failureReason === "Unknown processing error" && processingError) ? processingError.message : failureReason;
        success = false; // Ensure success is false if any error is caught
    } finally {
        // Update status to FAILED only if the process didn't fully complete successfully
        if (!success) {
            try {
                await supabase
                    .from('images')
                    .update({
                         status: 'FAILED',
                         // failure_reason: failureReason.substring(0, 255), // If column exists
                         updated_at: new Date().toISOString()
                        })
                    .eq('id', imageId);
                 console.log(`Upload Route: Marked image ID ${imageId} as FAILED in DB. Reason: ${failureReason}`);
            } catch (dbUpdateError) {
                console.error(`Upload Route: CRITICAL - Failed to update status to FAILED for image ID ${imageId} after processing error:`, dbUpdateError);
            }
        }
    }
}
// --- End Helper Function ---


// --- Main POST Handler ---
export async function POST(req: NextRequest) {
    let appleUserId: string;
    let imageId: number | string | null = null;
    let originalImageUrl: string | null = null;

    // --- Use Imported Environment Variable Check ---
    const envCheck = checkEnvVars(requiredEnvVars, 'Upload Route');
    if (!envCheck.valid) {
        return NextResponse.json({ error: `Internal Server Configuration Error: Missing env var: ${envCheck.missing}` }, { status: 500 });
    }
    // Retrieve validated environment variables
    const backendJwtSecret = process.env.BACKEND_JWT_SECRET as string;
    const supabaseUrl = process.env.SUPABASE_URL as string;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY as string;
    const awsRegion = process.env.AWS_REGION as string;
    const awsAccessKeyId = process.env.AWS_ACCESS_KEY_ID as string;
    const awsSecretAccessKey = process.env.AWS_SECRET_ACCESS_KEY as string;
    const awsS3BucketName = process.env.AWS_S3_BUCKET_NAME as string;
    const piApiKey = process.env.PIAPI_API_KEY as string;

    // Initialize S3 Client
    const s3Client = new S3Client({
        region: awsRegion,
        credentials: { accessKeyId: awsAccessKeyId, secretAccessKey: awsSecretAccessKey },
    });
    // Initialize Supabase Client
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
        auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false }
    });

    try {
        // --- 1. Verify Backend Session Token ---
        // (Code unchanged)
        const authHeader = req.headers.get('authorization');
        if (!authHeader || !authHeader.startsWith('Bearer ')) { return NextResponse.json({ error: 'Unauthorized: Missing or invalid Authorization header.' }, { status: 401 }); }
        const sessionToken = authHeader.substring(7);
        try {
            const decoded = jwt.verify(sessionToken, backendJwtSecret, { algorithms: ['HS256'], issuer: 'BrickAIBackend' });
            if (typeof decoded === 'object' && decoded !== null && typeof decoded.sub === 'string') { appleUserId = decoded.sub; }
            else { throw new Error('Invalid token payload structure or missing/invalid sub claim.'); }
            console.log(`Upload Route: Verified session token for Apple User ID (sub): ${appleUserId}`);
        } catch (err: unknown) {
             console.error('Upload Route: Backend Session Token Verification Error:', err instanceof Error ? err.message : 'Unknown error');
            let errorMessage = 'Unauthorized: Invalid session token.'; if (err instanceof Error && err.name === 'TokenExpiredError') { errorMessage = 'Unauthorized: Session has expired.'; }
             return NextResponse.json({ error: errorMessage }, { status: 401 });
        }

        // --- 2. Process Image Upload (Get image data) ---
        // (Code unchanged)
        const contentType = req.headers.get('content-type');
        if (!contentType || !contentType.startsWith('image/')) { return NextResponse.json({ error: 'Invalid Content-Type. Must be an image type.' }, { status: 400 }); }
        const buffer = await req.arrayBuffer();
        if (!buffer || buffer.byteLength === 0) { return NextResponse.json({ error: 'No image data received in request body' }, { status: 400 }); }
        const body = Buffer.from(buffer);

        // --- 3. Upload Original Image to S3 ---
        // (Code unchanged, uses utils)
        const fileExtension = getExtensionFromContentType(contentType);
        const s3Key = `images/${appleUserId}/${uuidv4()}.${fileExtension}`;
        const uploadParams = { Bucket: awsS3BucketName, Key: s3Key, Body: body, ContentType: contentType };
        console.log(`Upload Route: Uploading original image to S3 key: ${s3Key}`);
        await s3Client.send(new PutObjectCommand(uploadParams));
        console.log(`Upload Route: Successfully uploaded original image to S3.`);
        originalImageUrl = getS3Url(awsS3BucketName, awsRegion, s3Key);
        if (!originalImageUrl) {
             console.error('Upload Route: Failed to construct S3 URL after upload.');
             return NextResponse.json({ error: 'Failed to construct S3 URL after upload.' }, { status: 500 });
        }

        // --- 4. Save Initial Metadata to Supabase & Get ID ---
        // (Code unchanged)
        console.log(`Upload Route: Saving initial image metadata to Supabase for user ${appleUserId}`);
        const { data: insertedData, error: dbError } = await supabase.from('images').insert({ apple_user_id: appleUserId, original_s3_key: s3Key, status: 'UPLOADED' }).select('id').single();
        if (dbError) { console.error('Upload Route: Supabase insert error:', dbError); return NextResponse.json({ error: `Failed to save image metadata: ${dbError.message}` }, { status: 500 }); }
        if (!insertedData || !insertedData.id) { console.error('Upload Route: Supabase insert did not return the image ID.'); return NextResponse.json({ error: 'Failed to get image ID after saving metadata.' }, { status: 500 }); }
        imageId = insertedData.id;
        console.log(`Upload Route: Successfully saved metadata to Supabase. Image ID: ${imageId}`);

        // --- 5. Trigger Image Stream Processing and Update (Synchronous Call) ---
        console.log("Upload Route: Triggering synchronous image stream processing, accumulation, and update attempt...");
        await processImageAndLogStream( // Use the stream handling function
            supabase,
            s3Client,
            imageId || 0,
            originalImageUrl,
            appleUserId,
            awsS3BucketName,
            awsRegion,
            piApiKey
        );
         console.log("Upload Route: Synchronous stream processing and update function finished.");

        // --- 6. Construct and Return Response to Client ---
        // The response indicates acceptance; client needs to check status via /images endpoint
        return NextResponse.json({
            message: 'Image upload accepted, processing attempted via stream.', // Updated message
            url: originalImageUrl // Return original URL
        });

    } catch (err: unknown) {
        console.error('Upload Route: Unhandled Error in POST handler:', err instanceof Error ? err.message : 'Unknown error');
        // Attempt to mark as FAILED if we have an ID and DB connection
        if (imageId && supabase) {
             try {
                await supabase.from('images').update({ status: 'FAILED', updated_at: new Date().toISOString() }).eq('id', imageId).maybeSingle();
                console.log(`Upload Route: Marked image ID ${imageId} as FAILED due to unhandled error in handler.`);
             } catch (dbUpdateError) { console.error(`Upload Route: CRITICAL - Failed to update status to FAILED for image ID ${imageId} in main catch block:`, dbUpdateError); }
        }
        return NextResponse.json({ error: 'Internal server error during upload processing.' }, { status: 500 });
    }
}


function checkEnvVars(requiredEnvVars: string[], routeName?: string): { valid: boolean, missing?: string } {
  const prefix = routeName ? `${routeName}: ` : '';
  for (const varName of requiredEnvVars) {
      if (!process.env[varName]) {
          console.error(`${prefix}Missing required environment variable: ${varName}`);
          return { valid: false, missing: varName };
      }
  }
  // Optionally add more specific checks here if needed (e.g., check if private key looks valid)
  return { valid: true };
}



function getExtensionFromContentType(contentType: string | null): string {
  if (!contentType) return 'bin';
  const defaultExt = 'jpg'; // Keep jpg as default for images? Or 'bin'?
  switch (contentType.toLowerCase()) {
      case 'image/jpeg': return 'jpg';
      case 'image/png': return 'png';
      case 'image/gif': return 'gif';
      case 'image/webp': return 'webp';
      case 'image/svg+xml': return 'svg';
      // Add more common types if needed
      default:
          // Attempt to get extension from subtype more robustly
          const subtype = contentType.split('/')[1];
          // Handle potential parameters like 'charset=utf-8'
          return subtype ? subtype.split('+')[0].split(';')[0].trim() : defaultExt;
  }
}

function getS3Url(bucket: string, region: string, key: string | null | undefined): string | null {
   if (!key) return null;
   // Ensure key doesn't start with a '/' as it can cause issues with URL joining
   const effectiveKey = key.startsWith('/') ? key.substring(1) : key;
   // Use the virtual-hostedstyle URL format
   return `https://${bucket}.s3.${region}.amazonaws.com/${effectiveKey}`;
}
--- File End: web/src/app/api/upload/route.ts ---


