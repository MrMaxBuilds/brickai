--- File Start: ios-app/BrickAI/BrickAI/BrickAIApp.swift ---
// MARK: MODIFIED FILE - BrickAIApp.swift
//
//  BrickAIApp.swift
//  BrickAI
//
//  Created by Max U on 4/5/25.
//

import SwiftUI

@main
struct BrickAIApp: App {
    // Instantiate UserManager and ImageDataManager as StateObjects at the top level
    @StateObject private var userManager = UserManager.shared
    @StateObject private var imageDataManager = ImageDataManager()
    // <-----CHANGE START------>
    // Instantiate StoreManager as a StateObject
    @StateObject private var storeManager = StoreManager()
    // <-----CHANGE END-------->

    var body: some Scene {
        WindowGroup {
            // Pass all managers into the environment
            LoginView()
              .environmentObject(userManager)
              .environmentObject(imageDataManager)
              // <-----CHANGE START------>
              .environmentObject(storeManager) // Inject StoreManager
              // <-----CHANGE END-------->
        }
    }
}
// MARK: END MODIFIED FILE - BrickAIApp.swift

--- File End: ios-app/BrickAI/BrickAI/BrickAIApp.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/CameraManager.swift ---
import Foundation
import AVFoundation
import UIKit // Needed for UIImage
import Combine // Needed for ObservableObject

class CameraManager: ObservableObject {
    static let shared = CameraManager()
    let session = AVCaptureSession()

    // --- Published Properties ---
    @Published var capturedImage: UIImage? // Holds the image after capture
    @Published private(set) var isPermissionGranted: Bool = false // Camera permission state
    @Published private(set) var currentCameraPosition: AVCaptureDevice.Position = .back
    @Published private(set) var isFrontCameraActive: Bool = false // Added to track if front camera is active

    // --- Private Properties ---
    private var videoDeviceInput: AVCaptureDeviceInput?
    private let photoOutput = AVCapturePhotoOutput()
    // Add a delegate object to handle photo capture callbacks
    private var photoCaptureDelegate: PhotoCaptureProcessor?

    // --- Initialization ---
    private init() {
        print("CameraManager: Initializing...")
        checkCameraPermission() // Check initial permission status
        // Configure only if permission is initially granted, or defer until granted?
        // Let's configure regardless, session won't work without permission anyway.
        configureSession()
    }

    // --- Permission Handling ---
    func checkCameraPermission() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized: // The user has previously granted access to the camera.
            print("CameraManager: Permission already granted.")
            self.isPermissionGranted = true
        case .notDetermined: // The user has not yet been asked for camera access.
            print("CameraManager: Permission not determined yet.")
            self.isPermissionGranted = false
            // Don't request here automatically, let UI trigger request if needed
        case .denied: // The user has previously denied access.
             print("CameraManager: Permission denied previously.")
            self.isPermissionGranted = false
        case .restricted: // The user can't grant access due to restrictions.
             print("CameraManager: Permission restricted.")
            self.isPermissionGranted = false
        @unknown default:
             print("CameraManager: Unknown permission status.")
            self.isPermissionGranted = false
        }
    }

    func requestCameraPermission() {
         // Request on background thread? Apple docs don't specify, but UI updates should be main.
         AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
             DispatchQueue.main.async { // Update state on main thread
                 self?.isPermissionGranted = granted
                 if granted {
                     print("CameraManager: Permission granted by user.")
                     // Optionally start session immediately if configured and needed?
                     // self?.startSession()
                 } else {
                     print("CameraManager: Permission denied by user.")
                 }
             }
         }
    }

    // --- Session Configuration ---
    func configureSession() {
        // Should only run if session isn't already configured? Add check?
        guard session.inputs.isEmpty && session.outputs.isEmpty else {
             print("CameraManager: Session already configured.")
             return
        }

        session.beginConfiguration()
        session.sessionPreset = .photo // Use high quality preset

        // Find video device based on the current desired position (defaults to back)
        //<-----CHANGE START------>
        // Corrected the guard statement's else block
        var deviceToUse: AVCaptureDevice? = nil
        if let primaryDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: currentCameraPosition) {
             deviceToUse = primaryDevice
        } else {
             print("CameraManager Error: Failed to find primary camera for position \(currentCameraPosition). Attempting fallback.")
             let fallbackPosition: AVCaptureDevice.Position = (currentCameraPosition == .back) ? .front : .back
             if let fallbackDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: fallbackPosition) {
                  print("CameraManager: Using fallback camera position \(fallbackPosition)")
                  deviceToUse = fallbackDevice
                  currentCameraPosition = fallbackPosition // Update state if using fallback
             } else {
                  print("CameraManager Error: Failed to find fallback camera either.")
                  session.commitConfiguration() // Commit before returning
                  return // Exit scope if no device found
             }
        }

        // Ensure we actually have a device before proceeding
        guard let videoDevice = deviceToUse else {
             print("CameraManager Error: No suitable video device found after primary and fallback checks.")
             session.commitConfiguration() // Commit before returning
             return // Exit scope if device is still nil (shouldn't happen logically here but safer)
        }
        //<-----CHANGE END-------->

        // Create video input
        do {
             videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
        } catch {
            print("CameraManager Error: Could not create video device input: \(error)")
            session.commitConfiguration()
            return
        }

        // Add video input
        if let videoInput = videoDeviceInput, session.canAddInput(videoInput) {
            session.addInput(videoInput)
        } else {
            print("CameraManager Error: Could not add video device input to session.")
            session.commitConfiguration()
            return
        }

        // Add photo output
        if session.canAddOutput(photoOutput) {
            session.addOutput(photoOutput)
            photoOutput.isHighResolutionCaptureEnabled = true
            // Configure other settings like photo quality, stabilization if needed
        } else {
             print("CameraManager Error: Could not add photo output to session.")
            session.commitConfiguration()
            return
        }

        session.commitConfiguration()
        print("CameraManager: Session configured successfully for position \(currentCameraPosition).")
    }

    // --- Session Control ---
    // Start the session if permission is granted and it's not already running
    func startSession() {
        guard isPermissionGranted else {
            print("CameraManager: Cannot start session, permission not granted.")
            return
        }
        // Run on a background thread to avoid blocking UI
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            if !self.session.isRunning {
                self.session.startRunning()
                print("CameraManager: Session started running.")
            } else {
                 // print("CameraManager: Session already running.") // Less noisy log
            }
        }
    }

    // Stop the session if it's running
    func stopSession() {
        // Ensure stop is on background thread if start was
         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
               guard let self = self else { return }
               if self.session.isRunning {
                    self.session.stopRunning()
                    print("CameraManager: Session stopped running.")
               } else {
                   // print("CameraManager: Session already stopped.") // Less noisy log
               }
         }
    }

    // --- Photo Capture ---
    func capturePhoto() {
         guard session.isRunning else {
              print("CameraManager Error: Cannot capture photo, session is not running.")
              // Maybe try starting session? Or just return?
              return
         }
         guard isPermissionGranted else {
             print("CameraManager Error: Cannot capture photo, permission denied.")
             return
         }

         print("CameraManager: Initiating photo capture.")
         let settings = AVCapturePhotoSettings()
         // Configure settings (flash, quality, etc.) if needed
         // settings.flashMode = .auto // Example

         // Create a delegate object instance for this capture request
         // This delegate will handle receiving the photo data
         photoCaptureDelegate = PhotoCaptureProcessor { [weak self] image in
              // This completion block is called by the delegate when processing is done
              DispatchQueue.main.async { // Update published property on main thread
                  self?.capturedImage = image
                  print("CameraManager: Photo captured and processed. Updated published property.")
                  // Stop session after capture? Yes, typically done by HomeView's onChange.
                  // self?.stopSession()
              }
              // Release the delegate reference once capture is complete
               self?.photoCaptureDelegate = nil
         }

         // Initiate the capture
         photoOutput.capturePhoto(with: settings, delegate: photoCaptureDelegate!)
    }

    // --- State Reset ---
    // Call this from CapturedImageView (or HomeView) to dismiss the captured image view
    func resetCaptureState() {
        DispatchQueue.main.async { // Ensure UI updates on main thread
            self.capturedImage = nil
            print("CameraManager: Capture state reset (capturedImage set to nil).")
            // Should the session restart here? Let HomeView's onChange handle it.
        }
    }

    // --- Camera Switching ---
    func switchCamera() {
         guard session.isRunning else {
              print("CameraManager: Cannot switch camera, session is not running.")
              return
         }
         guard let currentInput = self.videoDeviceInput else {
              print("CameraManager: Cannot switch camera, current video input is nil.")
              return
         }

         // Determine the desired position
         let desiredPosition: AVCaptureDevice.Position = (currentInput.device.position == .back) ? .front : .back
         print("CameraManager: Attempting to switch camera to \(desiredPosition).")

         // Find the new device
         guard let newDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: desiredPosition) else {
              print("CameraManager Error: Failed to find camera for position \(desiredPosition).")
              return
         }

         // Create new input
         let newVideoInput: AVCaptureDeviceInput
         do {
              newVideoInput = try AVCaptureDeviceInput(device: newDevice)
         } catch {
              print("CameraManager Error: Could not create video input for \(desiredPosition): \(error)")
              return
         }

         // Perform the switch on the session (needs configuration block)
         session.beginConfiguration()

         // Remove the old input
         session.removeInput(currentInput)

         // Add the new input
         if session.canAddInput(newVideoInput) {
              session.addInput(newVideoInput)
              self.videoDeviceInput = newVideoInput // Update the stored input reference
              // Update the published state on the main thread
              DispatchQueue.main.async {
                   self.currentCameraPosition = desiredPosition
                   self.isFrontCameraActive = (desiredPosition == .front) // Update based on new position
              }
              print("CameraManager: Successfully switched camera to \(desiredPosition).")
         } else {
              print("CameraManager Error: Could not add new video input for \(desiredPosition). Re-adding old input.")
              // Attempt to re-add the old input if adding the new one failed
              if session.canAddInput(currentInput) {
                   session.addInput(currentInput)
              }
              // Don't update state if switch failed
         }

         // Commit the configuration changes
         session.commitConfiguration()
    }
}

// --- AVCapturePhotoCaptureDelegate Implementation ---
// Create a separate class to handle the delegate callbacks cleanly.
class PhotoCaptureProcessor: NSObject, AVCapturePhotoCaptureDelegate {
    // Completion handler to call back with the processed image
    private var completionHandler: (UIImage?) -> Void

    init(completion: @escaping (UIImage?) -> Void) {
        self.completionHandler = completion
        print("PhotoCaptureProcessor: Initialized.")
    }

    // This delegate method is called when the photo processing is complete
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        print("PhotoCaptureProcessor: didFinishProcessingPhoto called.")
        if let error = error {
            print("PhotoCaptureProcessor Error: Error capturing photo: \(error.localizedDescription)")
            completionHandler(nil)
            return
        }

        // Get image data
        guard let imageData = photo.fileDataRepresentation() else {
            print("PhotoCaptureProcessor Error: Could not get image data representation.")
            completionHandler(nil)
            return
        }

        // Create UIImage
        guard let capturedImage = UIImage(data: imageData) else {
             print("PhotoCaptureProcessor Error: Could not create UIImage from data.")
             completionHandler(nil)
             return
        }

        print("PhotoCaptureProcessor: Successfully processed photo into UIImage.")
        // Call the completion handler with the successful image
        completionHandler(capturedImage)
    }

     // You might implement other delegate methods if needed (e.g., willBeginCapture, didFinishCapture)
     func photoOutput(_ output: AVCapturePhotoOutput, willBeginCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
         print("PhotoCaptureProcessor: willBeginCapture...")
         // E.g., Trigger shutter sound or visual feedback
     }

     func photoOutput(_ output: AVCapturePhotoOutput, didFinishCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings, error: Error?) {
         if let error = error {
             print("PhotoCaptureProcessor: didFinishCapture with error: \(error)")
         } else {
             print("PhotoCaptureProcessor: didFinishCapture successfully.")
             // E.g., Stop shutter sound/visual feedback
         }
     }
}

--- File End: ios-app/BrickAI/BrickAI/Managers/CameraManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/ImageDataManager.swift ---
// MARK: MODIFIED FILE - Managers/ImageDataManager.swift
// File: BrickAI/Managers/ImageDataManager.swift
// Manages fetching the image list and preloading/caching image data.
// Updated prepareImageData to avoid clearing images prematurely during refresh.
// Replaced NSCache with Core Data for persistent image caching.
// Fixed optional binding error for url.absoluteString.
// Added background polling timer.
// Added pending upload queue and logic.
// Added property to track last successful upload time for notification.
// <-----CHANGE START------>
// Added computed property for actively processing image count.
// <-----CHANGE END-------->

import Foundation
import SwiftUI // For UIImage and ObservableObject
import Combine // For ObservableObject
import CoreData // Import Core Data


// Define the Core Data Entity Name
let coreDataEntityName = "CachedImageEntity"

@MainActor // Ensures @Published properties are updated on the main thread
class ImageDataManager: ObservableObject {

    // --- Published Properties for UI ---
    @Published var images: [ImageData] = []
    @Published var isLoadingList: Bool = false
    @Published var listError: NetworkError? = nil
    // Optional: Progress for preloading, could be 0.0 to 1.0
    @Published var preloadingProgress: Double = 0.0
    @Published var isPreloading: Bool = false
    // Queue for uploads initiated but not yet confirmed by backend fetch
    @Published var pendingUploads: [PendingUploadInfo] = []
    // Timestamp of the last successful background upload completion
    @Published var lastUploadSuccessTime: Date? = nil
    // Store previous image count to calculate acknowledged uploads
    private var previousImageCount: Int = 0

    //<-----CHANGE START------>
    // --- Computed Property for Actively Processing Count ---
    var activelyProcessingCount: Int {
        // Count items in the pending queue
        let pendingCount = pendingUploads.count
        // Count acknowledged images that are not in a final state (COMPLETED or FAILED)
        let processingAcknowledgedCount = images.filter { image in
            let upperStatus = image.status.uppercased()
            return upperStatus != "COMPLETED" && upperStatus != "FAILED"
        }.count
        // Return the sum
        return pendingCount + processingAcknowledgedCount
    }
    //<-----CHANGE END-------->


    // --- Caching ---
    // Core Data Persistent Container
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "BrickAI") // Use your Core Data Model name here
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)") // Consider non-fatal error handling
            } else {
                 print("ImageDataManager: Core Data store loaded: \(storeDescription.url?.absoluteString ?? "No URL")")
                 container.viewContext.automaticallyMergesChangesFromParent = true
            }
        })
        return container
    }()

    // Convenience accessor for the main context
    private var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }

    private let imagePreloadLimit = 20 // Configurable limit for preloading

    // --- Internal State ---
    private var fetchTask: Task<Void, Never>? = nil
    private var preloadTask: Task<Void, Never>? = nil
    // Track URLs currently being downloading (using String representation for Core Data compatibility)
    private var activeDownloads = Set<String>()
    // Timer for background polling
    private var pollingTimer: Timer?
    private let pollingInterval: TimeInterval = 5.0 // 5 seconds // DEBUG: Reduced interval

    init() {
        print("ImageDataManager: Initialized.")
        // Store initial count (will be 0 unless data loaded differently)
        self.previousImageCount = self.images.count
        // Start polling when the manager is initialized.
        // This assumes the manager is created when needed (e.g., at app launch or login).
        startPolling()
        // Initial fetch is triggered by the first timer fire, or can be called explicitly here if needed immediately:
        // prepareImageData()
    }

    // --- Public Methods ---

    /// Called by timer or for manual refresh to fetch the image list and then preload images.
    func prepareImageData() {
        // Don't cancel ongoing tasks if called rapidly (e.g., by timer + manual refresh)
        // unless current fetch is truly stale. Let existing fetch/preload complete.
        // Only start a new fetch if not already loading the list.
        guard !isLoadingList else {
             print("ImageDataManager: prepareImageData() called, but already loading list. Ignoring.")
             return
        }

        // Cancel previous *specific* tasks if needed, but generally let them run unless state demands cancellation.
        // fetchTask?.cancel() // Be cautious cancelling ongoing operations frequently
        // preloadTask?.cancel()

        // activeDownloads.removeAll() // Don't clear downloads if a preload might still be useful
        isPreloading = false // Reset preload state indicators for the new fetch cycle
        preloadingProgress = 0.0

        print("ImageDataManager: prepareImageData() called. Starting fetch task.")

        self.listError = nil
        self.isLoadingList = true // Mark as loading *before* starting the task

        fetchTask = Task {
            do {
                let fetchedImages = try await fetchImagesWithAsyncAwait()

                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before updating images.")
                    // Ensure isLoadingList is reset even if cancelled
                    if isLoadingList { isLoadingList = false }
                    return
                }

                // --- Pending Queue Decrement Logic ---
                let newlyFetchedCount = fetchedImages.count
                let acknowledgedCount = newlyFetchedCount - self.previousImageCount

                if acknowledgedCount > 0 {
                    print("ImageDataManager: Backend acknowledged \(acknowledgedCount) new image(s). Dequeuing from pending uploads.")
                    // Remove the oldest 'acknowledgedCount' items from the pending queue
                    let countToRemove = min(acknowledgedCount, self.pendingUploads.count) // Don't remove more than exist
                    if countToRemove > 0 {
                        self.pendingUploads.removeFirst(countToRemove)
                        print("ImageDataManager: Removed \(countToRemove) items. Pending queue size: \(self.pendingUploads.count)")
                    }
                }
                // Update the previous count *after* comparison
                self.previousImageCount = newlyFetchedCount
                // --- End Pending Queue Logic ---


                print("ImageDataManager: Successfully fetched \(fetchedImages.count) images.")
                // Only update images and trigger preload if the data has actually changed?
                // For simplicity, always update for now. Add comparison logic if needed.
                self.images = fetchedImages // Update the main image list
                self.isLoadingList = false // Mark as finished loading

                triggerImagePreloading()

            } catch let error as NetworkError {
                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before handling error.")
                    if isLoadingList { isLoadingList = false }
                    return
                }
                print("ImageDataManager: Error fetching images: \(error.localizedDescription)")
                self.listError = error
                self.isLoadingList = false // Mark as finished loading (with error)
                // Reset previous count on error? Maybe not, keep it for next successful fetch comparison.
                // self.previousImageCount = 0
            } catch {
                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before handling unknown error.")
                    if isLoadingList { isLoadingList = false }
                    return
                }
                print("ImageDataManager: Unknown error during image fetch: \(error)")
                self.listError = .unexpectedResponse
                self.isLoadingList = false // Mark as finished loading (with error)
                // Reset previous count on error? Maybe not.
                // self.previousImageCount = 0
            }
        }
    }

    /// Adds information about a newly initiated upload to the pending queue.
    func addImageToPendingQueue() {
        // Create info for the pending upload. No thumbnail stored for now.
        let pendingInfo = PendingUploadInfo()
        self.pendingUploads.append(pendingInfo)
        print("ImageDataManager: Added image to pending queue. Queue size: \(self.pendingUploads.count)")
        // No longer need to store backend count at time of upload.
        // Decrement logic handles it based on count increase during fetch.
    }


    /// Starts the background polling timer.
    func startPolling() {
        print("ImageDataManager: Starting polling timer with interval \(pollingInterval) seconds.")
        // Invalidate existing timer first
        stopPolling()
        // Schedule new timer
        pollingTimer = Timer.scheduledTimer(withTimeInterval: pollingInterval, repeats: true) { [weak self] _ in
             print("ImageDataManager: Polling timer fired.")
             // Call prepareImageData on the main actor instance
             self?.prepareImageData()
        }
        // Fire immediately on start? Optional.
         pollingTimer?.fire() // Uncomment to fetch immediately when polling starts
    }

    /// Stops the background polling timer.
    func stopPolling() {
        if pollingTimer != nil {
             print("ImageDataManager: Stopping polling timer.")
             pollingTimer?.invalidate()
             pollingTimer = nil
        }
    }


    /// Retrieves an image from the Core Data cache. Returns nil if not cached.
    func getImage(for url: URL?) -> UIImage? {
        // First, safely unwrap the optional URL
        guard let unwrappedUrl = url else { return nil }
        // Now that url is unwrapped, get the non-optional absoluteString
        let urlString = unwrappedUrl.absoluteString

        // Fetch from Core Data
        let request = NSFetchRequest<CachedImageEntity>(entityName: coreDataEntityName)
        request.predicate = NSPredicate(format: "url == %@", urlString)
        request.fetchLimit = 1

        do {
            // Fetch synchronously on the current thread (main actor)
            let results = try viewContext.fetch(request)
            if let cachedEntity = results.first, let imageData = cachedEntity.imageData {
                 // print("ImageDataManager: Cache hit for \(urlString)") // Verbose
                 return UIImage(data: imageData)
            } else {
                 // print("ImageDataManager: Cache miss for \(urlString)") // Verbose
                 return nil
            }
        } catch {
            print("ImageDataManager: Error fetching cached image from Core Data for \(urlString): \(error)")
            return nil
        }
    }

    /// Attempts to download and cache an image if not already cached or downloading.
    func ensureImageIsCached(for url: URL?) {
        // First, safely unwrap the optional URL
        guard let unwrappedUrl = url else { return }
        // Now that url is unwrapped, get the non-optional absoluteString
        let urlString = unwrappedUrl.absoluteString

        // Check cache first (using the new Core Data method)
        if getImage(for: unwrappedUrl) != nil { return }

        // Check if already downloading (using String URL)
        // Need to access activeDownloads carefully if this can be called from non-main thread
        // Since it's called from ImageRow's .task (MainActor), it should be safe.
        guard !activeDownloads.contains(urlString) else { return }

        print("ImageDataManager: Explicitly caching image for URL: \(urlString)")
        activeDownloads.insert(urlString) // Use String URL

        Task(priority: .background) {
            defer {
                // Ensure we remove from activeDownloads even if download fails
                Task { @MainActor in self.activeDownloads.remove(urlString) } // Use String URL
            }
            // Use the unwrapped URL for downloading
            if let image = await downloadImage(url: unwrappedUrl) {
                 // Save downloaded image to Core Data (on background thread)
                 saveImageToCoreData(image: image, forKey: urlString)
                 print("ImageDataManager: Successfully cached explicit request: \(urlString)")
            }
            // No need to update progress for explicit caching
        }
    }


    // --- Private Helper Methods ---

    /// Wraps the NetworkManager's completion-handler based fetch in an async function.
    private func fetchImagesWithAsyncAwait() async throws -> [ImageData] {
        try await withCheckedThrowingContinuation { continuation in
            NetworkManager.fetchImages { result in
                switch result {
                case .success(let images):
                    continuation.resume(returning: images)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Initiates the background task to preload images.
    private func triggerImagePreloading() {
        preloadTask?.cancel() // Cancel any previous preload task
        activeDownloads.removeAll() // Clear active downloads for the new preload cycle
        isPreloading = true // Indicate preloading has started
        preloadingProgress = 0.0 // Reset progress

        // Get the list of images to preload based on the latest fetched data
        let imagesToPreload = Array(images.prefix(imagePreloadLimit))
        guard !imagesToPreload.isEmpty else {
            print("ImageDataManager: No images to preload.")
            isPreloading = false // Nothing to preload
            return
        }
        let totalToPreload = imagesToPreload.count
        var successfullyPreloadedCount = 0 // Track successful downloads *in this cycle*

        print("ImageDataManager: Starting preload task for up to \(totalToPreload) images.")

        preloadTask = Task(priority: .background) { // Run preloading in background
            for imageData in imagesToPreload {
                 // Check for cancellation before each potential download
                guard !Task.isCancelled else {
                    print("ImageDataManager: Preload task cancelled.")
                    break // Exit the loop
                }

                // Prefer processed, fallback to original
                // Safely unwrap the URL first
                guard let url = imageData.processedImageUrl ?? imageData.originalImageUrl else {
                    continue // Skip if no valid URL for this item
                }
                // Get the non-optional string
                let urlString = url.absoluteString

                // Skip if already cached (checks Core Data now using the unwrapped URL)
                // Perform cache check within the task's actor context (MainActor here)
                if getImage(for: url) != nil {
                    // print("ImageDataManager: Preload skipping already cached: \(urlString)") // Verbose
                    continue // Move to the next image
                }

                // Skip if already downloading (using String URL)
                // Accessing activeDownloads needs to be safe if Task is not on MainActor
                // Since ImageDataManager is @MainActor, this access is safe.
                guard !activeDownloads.contains(urlString) else { continue }

                activeDownloads.insert(urlString) // Mark as downloading *before* starting await
                // Use the unwrapped URL for downloading
                if let image = await downloadImage(url: url) {
                    // Check for cancellation *after* download but *before* caching
                    guard !Task.isCancelled else {
                         print("ImageDataManager: Preload task cancelled after download, before caching \(urlString).")
                         break
                    }
                    // Save to Core Data (on background thread)
                    saveImageToCoreData(image: image, forKey: urlString)
                    print("ImageDataManager: Preloaded and cached: \(urlString)")
                    successfullyPreloadedCount += 1 // Count successful downloads
                } else {
                    // Download failed (error already logged by downloadImage)
                    print("ImageDataManager: Preload failed for: \(urlString)")
                    // Don't increment success count on failure
                }
                 // Remove from active downloads set after attempt finishes (using String URL)
                Task { @MainActor in activeDownloads.remove(urlString) }


                // Check for cancellation before updating progress
                guard !Task.isCancelled else {
                     print("ImageDataManager: Preload task cancelled before progress update.")
                     break
                }
                 // Update progress on main thread based on successful downloads
                updatePreloadProgress(current: successfullyPreloadedCount, total: totalToPreload)

            } // End loop

             // Final state update after loop finishes or breaks
            Task { @MainActor in
                 // Calculate final progress based on successful downloads vs total targeted
                 let finalProgress = totalToPreload > 0 ? Double(successfullyPreloadedCount) / Double(totalToPreload) : 1.0
                 print("ImageDataManager: Preload task finished. Successfully downloaded \(successfullyPreloadedCount)/\(totalToPreload) target images. Final Progress: \(finalProgress)")
                 self.isPreloading = false // Mark preloading as complete
                 self.preloadingProgress = finalProgress // Set final progress
                 self.activeDownloads.removeAll() // Ensure clear at the very end
            }
        }
    }

    /// Downloads a single image from a URL. Takes a non-optional URL.
    private func downloadImage(url: URL) async -> UIImage? { // Expects non-optional URL
        do {
            // Use default URLSession; configure cache policy if needed
            let request = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad) // Standard policy
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                print("ImageDataManager: Failed to download image from \(url.lastPathComponent) - Status: \((response as? HTTPURLResponse)?.statusCode ?? 0)")
                return nil
            }

            guard let image = UIImage(data: data) else {
                 print("ImageDataManager: Failed to create UIImage from downloaded data for \(url.lastPathComponent)")
                 return nil
            }
            return image
        } catch {
             // Handle cancellation error specifically
            if (error as? URLError)?.code == .cancelled {
                 print("ImageDataManager: Download cancelled for \(url.lastPathComponent).")
            } else {
                 print("ImageDataManager: Error downloading image \(url.lastPathComponent): \(error.localizedDescription)")
            }
            return nil
        }
    }

    /// Updates the preloading progress (ensures it runs on main thread).
    private func updatePreloadProgress(current: Int, total: Int) {
        guard total > 0 else { return }
        // Calculate progress based on successful downloads vs total items targeted
        let progress = Double(current) / Double(total)
        // Ensure update happens on MainActor
        // Task { @MainActor in self.preloadingProgress = progress } // Already on MainActor
        self.preloadingProgress = progress
    }

    /// Saves an image to Core Data. Uses a background context. Takes a non-optional String key.
    func saveImageToCoreData(image: UIImage, forKey urlString: String) { // Expects non-optional String key
        // Use PNG representation for potentially better quality/lossless, or JPEG for space saving
        guard let imageData = image.pngData() else { // Or image.jpegData(compressionQuality: 0.8)
            print("ImageDataManager: Failed to get PNG data for image \(urlString)")
            return
        }

        // Perform Core Data operations on a background context
        let context = persistentContainer.newBackgroundContext()
        context.perform { // Use perform to ensure operations are on the context's queue
            let request = NSFetchRequest<CachedImageEntity>(entityName: coreDataEntityName)
            request.predicate = NSPredicate(format: "url == %@", urlString)
            request.fetchLimit = 1

            do {
                let results = try context.fetch(request)
                let entity: CachedImageEntity
                if let existingEntity = results.first {
                     entity = existingEntity
                     // print("ImageDataManager: Updating existing Core Data cache entry for \(urlString)") // Verbose
                } else {
                     entity = CachedImageEntity(context: context)
                     entity.url = urlString
                     // print("ImageDataManager: Creating new Core Data cache entry for \(urlString)") // Verbose
                }
                entity.imageData = imageData
                entity.lastAccessed = Date() // Optional: Track last access time

                try context.save()
                 // print("ImageDataManager: Saved image to Core Data context for \(urlString).") // Verbose

            } catch {
                print("ImageDataManager: Failed to save image to Core Data for key \(urlString): \(error)")
                 context.rollback() // Rollback changes on error
            }
        }
    }


    /// Clears the entire Core Data image cache.
    func clearCache() {
        // Stop polling before clearing cache
        stopPolling()
        // Cancel any ongoing downloads/preloading
        activeDownloads.removeAll()
        preloadTask?.cancel()
        isPreloading = false
        // Clear pending queue and reset count on manual cache clear
        pendingUploads.removeAll()
        previousImageCount = 0
        print("ImageDataManager: Cleared pending uploads queue during cache clear.")


        // Perform delete on a background context
        let context = persistentContainer.newBackgroundContext()
        context.perform {
            let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: coreDataEntityName)
            let batchDeleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
            batchDeleteRequest.resultType = .resultTypeObjectIDs

            do {
                let result = try context.execute(batchDeleteRequest) as? NSBatchDeleteResult
                 if let objectIDs = result?.result as? [NSManagedObjectID], !objectIDs.isEmpty {
                      print("ImageDataManager: Batch deleted \(objectIDs.count) items from Core Data.")
                      // Merge changes back to the main context
                      let changes = [NSDeletedObjectsKey: objectIDs]
                      NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [self.viewContext])
                 } else {
                      print("ImageDataManager: Core Data image cache cleared (batch delete executed, 0 items deleted or IDs not returned).")
                 }
                // Save the context after successful batch delete
                 // No explicit save needed after batch delete if context is just for this operation?
                 // However, saving ensures consistency if other changes were pending. Let's keep it.
                 // try context.save() // Redundant? Batch delete persists directly. Removed.

            } catch {
                print("ImageDataManager: Failed to clear Core Data image cache: \(error)")
                // Rollback is implicitly handled by not saving if execute fails
                // context.rollback() // Not needed here
            }
        }
    }
}
// MARK: END MODIFIED FILE - Managers/ImageDataManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/ImageDataManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/KeychainService.swift ---
// File: BrickAI/Managers/KeychainService.swift
// Full Untruncated File

import Foundation
import Security

// Service identifier for Keychain items specific to this app
// Using the bundle ID is a common practice to avoid collisions
let kKeychainService = Bundle.main.bundleIdentifier ?? "com.default.keychainservice"

// Account keys used to identify specific data items
let kKeychainAccountUserIdentifier = "appleUserIdentifier"
let kKeychainAccountSessionToken = "backendSessionToken" // Key for storing our backend session token
let kKeychainAccountUserName = "userName" // Can also store username if desired

enum KeychainError: Error, LocalizedError {
    case itemNotFound
    case duplicateItem // Although we try to avoid this with delete-then-add or update
    case unexpectedData
    case unhandledError(status: OSStatus)

    var errorDescription: String? {
        switch self {
        case .itemNotFound:
            return "Keychain item not found."
        case .duplicateItem:
            return "Keychain item already exists."
        case .unexpectedData:
            return "Unexpected data format retrieved from Keychain."
        case .unhandledError(let status):
            // Provide a more descriptive error if possible using SecCopyErrorMessageString
            // However, that function is not available on all platforms/versions directly in Swift easily.
            return "Keychain operation failed with OSStatus: \(status)"
        }
    }
}

struct KeychainService {

    // Generic function to save data to Keychain
    static func saveData(_ data: Data, forKey accountKey: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey,
            kSecValueData as String: data,
            // Set accessibility - item accessible only when device is unlocked
            // This is a reasonable default for user credentials/tokens.
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        // Delete existing item first to ensure we replace it cleanly.
        // This simplifies the logic compared to checking existence then deciding Add vs Update.
        // Ignore itemNotFound error during delete, as it means we're just adding fresh.
        do {
            try deleteData(forKey: accountKey)
        } catch KeychainError.itemNotFound {
            // This is expected if the item doesn't exist yet. Continue to add.
        } catch {
             // Rethrow other unexpected delete errors
             throw error
        }


        // Add the new item
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            // If deletion failed silently and we hit duplicate, something is wrong.
            print("Keychain: Error saving data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
         print("Keychain: Successfully saved data for key '\(accountKey)'")
    }

    // Generic function to load data from Keychain
    static func loadData(forKey accountKey: String) throws -> Data {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey,
            kSecMatchLimit as String: kSecMatchLimitOne,  // We expect only one item per key
            kSecReturnData as String: kCFBooleanTrue!     // Request data back
        ]

        var item: CFTypeRef? // Use CFTypeRef for the result
        let status = SecItemCopyMatching(query as CFDictionary, &item)

        // Check for specific errors
        guard status != errSecItemNotFound else {
            throw KeychainError.itemNotFound
        }
        // Check for generic success
        guard status == errSecSuccess else {
            print("Keychain: Error loading data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
        // Check if the retrieved item is actually Data
        guard let data = item as? Data else {
            // This indicates an unexpected item type was stored or retrieved
            throw KeychainError.unexpectedData
        }

        print("Keychain: Successfully loaded data for key '\(accountKey)'")
        return data
    }

    // Generic function to update existing data in Keychain (Less used with delete-then-add strategy)
    // Kept for completeness or alternative implementations.
    static func updateData(_ data: Data, forKey accountKey: String) throws {
         let query: [String: Any] = [
             kSecClass as String: kSecClassGenericPassword,
             kSecAttrService as String: kKeychainService,
             kSecAttrAccount as String: accountKey
             // Do not specify kSecMatchLimitOne for update
         ]

         // Attributes to update
         let attributes: [String: Any] = [
             kSecValueData as String: data
             // Could potentially update kSecAttrAccessible here too if needed
         ]

         let status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)
         // Check specific errors
         guard status != errSecItemNotFound else {
             // Cannot update an item that doesn't exist
             throw KeychainError.itemNotFound
         }
         // Check generic success
         guard status == errSecSuccess else {
            print("Keychain: Error updating data for key '\(accountKey)'. Status: \(status)")
             throw KeychainError.unhandledError(status: status)
         }
          print("Keychain: Successfully updated data for key '\(accountKey)'")
     }


    // Generic function to delete data from Keychain
    static func deleteData(forKey accountKey: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey
            // No kSecMatchLimit needed for delete (deletes all matching if multiple existed, though our keys should be unique)
        ]

        let status = SecItemDelete(query as CFDictionary)
        // Treat itemNotFound as success (idempotent delete)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            print("Keychain: Error deleting data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
         if status == errSecSuccess {
              print("Keychain: Successfully deleted data for key '\(accountKey)'")
         } else {
              // This log might be redundant if throwing itemNotFound, but useful for clarity
              print("Keychain: No data found to delete for key '\(accountKey)'")
         }
    }

    // --- Convenience methods for String ---

    static func saveString(_ string: String, forKey accountKey: String) throws {
        // Convert String to Data using UTF-8 encoding
        guard let data = string.data(using: .utf8) else {
            print("Error converting string to data for key: \(accountKey)")
            // Throw an appropriate error if conversion fails
            throw KeychainError.unexpectedData // Or a more specific encoding error
        }
        // Call the primary saveData function
        try saveData(data, forKey: accountKey)
    }

    static func loadString(forKey accountKey: String) -> String? {
        do {
            // Call the primary loadData function
            let data = try loadData(forKey: accountKey)
            // Convert retrieved Data back to String using UTF-8
            return String(data: data, encoding: .utf8)
        } catch KeychainError.itemNotFound {
            // Item not found is often an expected case during loading, return nil
            print("Keychain: No string found for key '\(accountKey)'")
            return nil
        } catch {
            // Log other unexpected errors during loading
            print("Keychain: Failed to load string for key '\(accountKey)': \(error.localizedDescription)")
            return nil // Return nil on other errors
        }
    }
}

--- File End: ios-app/BrickAI/BrickAI/Managers/KeychainService.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/NetworkManager.swift ---
// MARK: MODIFIED FILE - Managers/NetworkManager.swift
// File: BrickAI/Managers/NetworkManager.swift
// Full Untruncated File - Added Equatable conformance to NetworkError.

import Foundation
import UIKit

// MARK: <<< ADDED START >>>
// UserInfo struct to match backend response
struct UserInfo: Decodable {
    let appleUserId: String
    let credits: Int
}

// MARK: <<< ADDED START >>>
// Specific response structures for API endpoints
struct AddCreditsResponse: Decodable {
    let message: String
    let userInfo: UserInfo
}

struct UploadResponse: Decodable {
    let message: String
    let url: String?
    let userInfo: UserInfo
}

struct ImagesResponse: Decodable {
    let images: [ImageData] // Assumes ImageData is Decodable
    let userInfo: UserInfo
}
// MARK: <<< ADDED END >>>

// MARK: <<< MODIFIED START >>>
// NetworkError Enum - Added Equatable conformance
enum NetworkError: Error, LocalizedError, Equatable {
// MARK: <<< MODIFIED END >>>
    case invalidURL(String)
    case dataConversionFailed
    case authenticationTokenMissing
    case networkRequestFailed(Error)
    case serverError(statusCode: Int, message: String?)
    case unauthorized // Specific 401 before refresh attempt
    case unexpectedResponse
    case authCodeExchangeFailed(String)
    case tokenRefreshFailed(String)
    case sessionExpired // Terminal refresh failure

    var errorDescription: String? {
        switch self {
        case .invalidURL(let urlString): return "The configured API endpoint URL is invalid: \(urlString)"
        case .dataConversionFailed: return "Failed to convert image to data format."
        case .authenticationTokenMissing: return "User authentication token is missing. Please log in."
        case .networkRequestFailed(let underlyingError): return "Network request failed: \(underlyingError.localizedDescription)"
        case .serverError(let statusCode, let message):
             var desc = "Server returned an error (Status Code: \(statusCode))."
             if let msg = message, !msg.isEmpty { desc += " Message: \(msg)" }
             return desc
        case .unauthorized: return "Unauthorized: Session may require refresh."
        case .unexpectedResponse: return "Received an unexpected response format from the server."
        case .authCodeExchangeFailed(let message): return "Failed to exchange authorization code with backend: \(message)"
        case .tokenRefreshFailed(let message): return "Failed to refresh session token: \(message)"
        case .sessionExpired: return "Your session has expired. Please log in again."
        }
    }

    // MARK: <<< ADDED START >>>
    // Implementation of Equatable conformance
    static func == (lhs: NetworkError, rhs: NetworkError) -> Bool {
        switch (lhs, rhs) {
        case (.invalidURL(let lhsString), .invalidURL(let rhsString)):
            return lhsString == rhsString
        case (.dataConversionFailed, .dataConversionFailed):
            return true
        case (.authenticationTokenMissing, .authenticationTokenMissing):
            return true
        case (.networkRequestFailed(let lhsError), .networkRequestFailed(let rhsError)):
            // Comparing actual Error objects is difficult.
            // Compare based on localizedDescription for pragmatic equality check.
            return lhsError.localizedDescription == rhsError.localizedDescription
        case (.serverError(let lhsCode, let lhsMessage), .serverError(let rhsCode, let rhsMessage)):
            return lhsCode == rhsCode && lhsMessage == rhsMessage
        case (.unauthorized, .unauthorized):
            return true
        case (.unexpectedResponse, .unexpectedResponse):
            return true
        case (.authCodeExchangeFailed(let lhsMessage), .authCodeExchangeFailed(let rhsMessage)):
            return lhsMessage == rhsMessage
        case (.tokenRefreshFailed(let lhsMessage), .tokenRefreshFailed(let rhsMessage)):
            return lhsMessage == rhsMessage
        case (.sessionExpired, .sessionExpired):
            return true
        // If none of the cases match, they are not equal
        default:
            return false
        }
    }
    // MARK: <<< ADDED END >>>
}

// Actor to manage the refresh token state and prevent race conditions
actor TokenRefresher {
    private var isRefreshing = false
    // Stores continuations waiting for the refresh to complete
    private var waitingContinuations: [CheckedContinuation<String, Error>] = []

    // Attempts to refresh the token, ensuring only one refresh happens at a time.
    func refreshTokenIfNeeded() async throws -> String {
        if !isRefreshing {
            isRefreshing = true
            // Perform the actual refresh network call
            do {
                // IMPORTANT: Call the static function on NetworkManager, not directly accessing self
                let newToken = try await NetworkManager.performTokenRefresh()

                // Notify all waiting tasks with the new token - this runs on the actor
                waitingContinuations.forEach { $0.resume(returning: newToken) }
                waitingContinuations.removeAll()
                isRefreshing = false
                print("TokenRefresher: Refresh successful, notified \(waitingContinuations.count) waiters.")
                return newToken
            } catch {
                // Notify all waiting tasks about the failure - this runs on the actor
                print("TokenRefresher: Refresh failed, notifying \(waitingContinuations.count) waiters.")
                waitingContinuations.forEach { $0.resume(throwing: error) }
                waitingContinuations.removeAll()
                isRefreshing = false
                throw error // Re-throw the error
            }
        } else {
            // If already refreshing, wait for the result
            print("TokenRefresher: Refresh already in progress, waiting...")
            return try await withCheckedThrowingContinuation { continuation in
                 // Accessing actor state directly inside the actor's async function.
                 // The continuation itself is Sendable.
                 self.waitingContinuations.append(continuation)
            }
        }
    }
} // End Actor


class NetworkManager {

    private static let tokenRefresher = TokenRefresher() // Instance of the actor

    private static var jsonDecoder: JSONDecoder = {
        let decoder = JSONDecoder()
        // Use a custom formatter that handles fractional seconds and timezone
        decoder.dateDecodingStrategy = .formatted(DateFormatter.iso8601Full)
        return decoder
    }()
    
    private static var baseApiEndpointURL: URL? {
        guard let urlString = Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String else { return nil }
        let correctedUrlString = urlString.hasSuffix("/") ? urlString : urlString + "/"
        guard let url = URL(string: correctedUrlString) else { return nil }
        return url
    }
    
    private static func endpointURL(path: String) -> URL? {
        let correctedPath = path.starts(with: "/") ? String(path.dropFirst()) : path
        return baseApiEndpointURL?.appendingPathComponent(correctedPath)
    }

    // Centralized Request Execution Function
    private static func performRequest(
        originalRequest: URLRequest,
        completion: @escaping (Result<Data, NetworkError>) -> Void
    ) {
        let mainThreadCompletion = { result in DispatchQueue.main.async { completion(result) } }

        guard let token = UserManager.shared.getSessionToken() else {
            mainThreadCompletion(.failure(.authenticationTokenMissing))
            return
        }
        var request = originalRequest
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            // MARK: <<< MODIFIED START >>>
            // Always try to extract user credits from data, regardless of error or status code, if data exists
            if let data = data {
                self.tryExtractAndUpdateUserCredits(from: data)
            }
            // MARK: <<< MODIFIED END >>>

            if let error = error {
                mainThreadCompletion(.failure(.networkRequestFailed(error)))
                return
            }
            guard let httpResponse = response as? HTTPURLResponse else {
                mainThreadCompletion(.failure(.serverError(statusCode: 0, message: "Invalid response type")))
                return
            }

            // Check for Unauthorized (401)
            if httpResponse.statusCode == 401 {
                print("NetworkManager: Received 401 Unauthorized for \(request.url?.absoluteString ?? "URL"). Attempting token refresh...")
                Task { // Use Task to call async actor function
                    do {
                        let newToken = try await tokenRefresher.refreshTokenIfNeeded()
                        print("NetworkManager: Token refresh successful via actor. Retrying original request...")

                        var retryRequest = originalRequest
                        retryRequest.setValue("Bearer \(newToken)", forHTTPHeaderField: "Authorization")

                        let retryTask = URLSession.shared.dataTask(with: retryRequest) { retryData, retryResponse, retryError in
                            // MARK: <<< MODIFIED START >>>
                            // Always try to extract user credits from retryData if it exists
                            if let retryData = retryData {
                                self.tryExtractAndUpdateUserCredits(from: retryData)
                            }
                            // MARK: <<< MODIFIED END >>>

                            if let retryError = retryError {
                                mainThreadCompletion(.failure(.networkRequestFailed(retryError)))
                                return
                            }
                            guard let retryHttpResponse = retryResponse as? HTTPURLResponse else {
                                mainThreadCompletion(.failure(.serverError(statusCode: 0, message: "Invalid retry response type")))
                                return
                            }

                            if retryHttpResponse.statusCode == 401 { // If retry STILL fails with 401
                                print("NetworkManager: Retry request failed with 401. Session expired.")
                                UserManager.shared.clearUser()
                                mainThreadCompletion(.failure(.sessionExpired))
                                return
                            }
                            guard (200...299).contains(retryHttpResponse.statusCode) else {
                                let errorMessage = parseError(from: retryData, statusCode: retryHttpResponse.statusCode)
                                mainThreadCompletion(.failure(.serverError(statusCode: retryHttpResponse.statusCode, message: errorMessage)))
                                return
                            }
                            mainThreadCompletion(.success(retryData ?? Data()))
                        }
                        retryTask.resume()

                    } catch let refreshError as NetworkError {
                        print("NetworkManager: Token refresh failed: \(refreshError.localizedDescription)")
                        if case .sessionExpired = refreshError { UserManager.shared.clearUser() }
                        mainThreadCompletion(.failure(refreshError))
                    } catch {
                        print("NetworkManager: Unexpected error during token refresh: \(error.localizedDescription)")
                        mainThreadCompletion(.failure(.tokenRefreshFailed("Unexpected error during refresh.")))
                    }
                } // End Task
            } else { // Not a 401 error
                guard (200...299).contains(httpResponse.statusCode) else {
                    let errorMessage = parseError(from: data, statusCode: httpResponse.statusCode)
                    mainThreadCompletion(.failure(.serverError(statusCode: httpResponse.statusCode, message: errorMessage)))
                    return
                }
                mainThreadCompletion(.success(data ?? Data()))
            }
        }
        task.resume()
    }

    // Internal function to perform the actual token refresh API call
    static func performTokenRefresh() async throws -> String {
        print("NetworkManager: Executing performTokenRefresh...")
        guard let refreshURL = endpointURL(path: "api/auth/refresh") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/auth/refresh"
            throw NetworkError.invalidURL(urlString)
        }
        guard let currentToken = UserManager.shared.getSessionToken() else { throw NetworkError.authenticationTokenMissing }

        var request = URLRequest(url: refreshURL)
        request.httpMethod = "POST"
        request.setValue("Bearer \(currentToken)", forHTTPHeaderField: "Authorization")

        let data: Data
        let response: URLResponse
        do {
            (data, response) = try await URLSession.shared.data(for: request)
        } catch {
            throw NetworkError.networkRequestFailed(error)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.serverError(statusCode: 0, message: "Invalid response type")
        }

        if httpResponse.statusCode == 401 {
            throw NetworkError.sessionExpired // Treat 401 from refresh endpoint as session expired
        }
        guard (200...299).contains(httpResponse.statusCode) else {
            let errorMessage = parseError(from: data, statusCode: httpResponse.statusCode)
            throw NetworkError.tokenRefreshFailed(errorMessage)
        }

        // Parse success response
        do {
            if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let newToken = jsonResponse["sessionToken"] as? String {
                UserManager.shared.updateSessionToken(newToken: newToken) // Update Keychain
                print("NetworkManager: Successfully received and saved new session token.")
                return newToken
            } else {
                throw NetworkError.unexpectedResponse
            }
        } catch {
            throw NetworkError.unexpectedResponse
        }
    }

    // Helper to parse error messages
    private static func parseError(from data: Data?, statusCode: Int) -> String {
        guard let data = data else { return "No error details provided." }
        do {
            if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let errorMsg = json["error"] as? String {
                return errorMsg
            }
        } catch {
            // Ignore
        }
        return String(data: data, encoding: .utf8) ?? "Could not decode error message."
    }

    // Public API Functions
    static func uploadImage(_ image: UIImage, completion: @escaping (Result<String, NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/upload") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/upload"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            DispatchQueue.main.async { completion(.failure(.dataConversionFailed)) }
            return
        }
        
        var request = URLRequest(url: endpoint)
        request.httpMethod = "POST"
        request.setValue("image/jpeg", forHTTPHeaderField: "Content-Type")
        request.httpBody = imageData

        performRequest(originalRequest: request) { result in
            switch result {
            case .success(let data):
                do {
                    let uploadResponse = try self.jsonDecoder.decode(UploadResponse.self, from: data)
                    if let urlString = uploadResponse.url {
                        completion(.success(urlString))
                    } else {
                        print("NetworkManager: Upload successful but no URL in response.")
                        completion(.failure(.unexpectedResponse))
                    }
                } catch {
                    print("NetworkManager: Failed to decode UploadResponse: \(error.localizedDescription). Data: \(String(data: data, encoding: .utf8) ?? "non-utf8 data")")
                    completion(.failure(.unexpectedResponse))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    // exchangeAuthCode remains separate
    static func exchangeAuthCode(authorizationCode: String, completion: @escaping (Result<String, NetworkError>) -> Void) {
        guard let authCallbackURL = endpointURL(path: "api/auth/apple/callback") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/auth/apple/callback"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }
        
        let requestBody: [String: String] = ["authorizationCode": authorizationCode]
        guard let jsonData = try? JSONEncoder().encode(requestBody) else {
            DispatchQueue.main.async { completion(.failure(.authCodeExchangeFailed("Failed to encode request."))) }
            return
        }
        
        var request = URLRequest(url: authCallbackURL)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(.networkRequestFailed(error)))
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    completion(.failure(.serverError(statusCode: 0, message: "Invalid response type")))
                    return
                }
                
                guard let responseData = data else {
                    completion(.failure(.serverError(statusCode: httpResponse.statusCode, message: "Missing response data.")))
                    return
                }
                
                var serverMessage: String? = nil
                var sessionToken: String? = nil
                
                do {
                    if let jsonResponse = try JSONSerialization.jsonObject(with: responseData) as? [String: Any] {
                        serverMessage = jsonResponse["error"] as? String ?? jsonResponse["message"] as? String
                        sessionToken = jsonResponse["sessionToken"] as? String
                    } else {
                        serverMessage = String(data: responseData, encoding: .utf8)
                    }
                } catch {
                    serverMessage = String(data: responseData, encoding: .utf8)
                }
                
                if (200...299).contains(httpResponse.statusCode), let token = sessionToken {
                    completion(.success(token))
                } else {
                    let errorMessage = serverMessage ?? "Auth code exchange failed status \(httpResponse.statusCode)."
                    completion(.failure(.authCodeExchangeFailed(errorMessage)))
                }
            }
        }
        task.resume()
    }

    static func fetchImages(completion: @escaping (Result<[ImageData], NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/images") else {
            DispatchQueue.main.async { completion(.failure(.invalidURL("images"))) }
            return
        }
        
        var request = URLRequest(url: endpoint)
        request.httpMethod = "GET"
        print("NetworkManager: Fetching images...")
        
        performRequest(originalRequest: request) { result in
            switch result {
            case .success(let data):
                do {
                    let imagesResponse = try self.jsonDecoder.decode(ImagesResponse.self, from: data)
                    print("NetworkManager: Successfully fetched and decoded \(imagesResponse.images.count) images.")
                    completion(.success(imagesResponse.images))
                } catch {
                    print("NetworkManager: Failed to decode ImagesResponse: \(error.localizedDescription). Data: \(String(data: data, encoding: .utf8) ?? "non-utf8 data")")
                    completion(.failure(.unexpectedResponse))
                }
            case .failure(let error):
                print("NetworkManager: Failed to fetch images: \(error.localizedDescription)")
                completion(.failure(error))
            }
        }
    }

    // Added function to call the delete account API endpoint
    static func deleteAccount(completion: @escaping (Result<Void, NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/account/delete") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/account/delete"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }

        var request = URLRequest(url: endpoint)
        request.httpMethod = "DELETE"
        print("NetworkManager: Requesting account deletion...")

        performRequest(originalRequest: request) { result in
            switch result {
            case .success: // If performRequest succeeds, it means a 2xx response was received.
                // The backend returns a JSON message, but for the client, a 200/204 means success.
                print("NetworkManager: Account deletion request successful.")
                completion(.success(()))
            case .failure(let error):
                print("NetworkManager: Account deletion request failed: \(error.localizedDescription)")
                completion(.failure(error))
            }
        }
    }

    static func addCreditsForPurchase(productId: String, completion: @escaping (Result<Int, NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/credits/add") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/credits/add"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }

        let requestBody: [String: String] = ["productId": productId]
        guard let jsonData = try? JSONEncoder().encode(requestBody) else {
            DispatchQueue.main.async { completion(.failure(.dataConversionFailed)) } // Or a more specific error
            return
        }

        var request = URLRequest(url: endpoint)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData

        print("NetworkManager: Attempting to add credits for product ID: \(productId)")

        performRequest(originalRequest: request) { result in
            switch result {
            case .success(let data):
                do {
                    let addCreditsResponse = try self.jsonDecoder.decode(AddCreditsResponse.self, from: data)
                    print("NetworkManager: Successfully added credits. New total from userInfo: \(addCreditsResponse.userInfo.credits)")
                    completion(.success(addCreditsResponse.userInfo.credits))
                } catch {
                    print("NetworkManager: Failed to decode AddCreditsResponse: \(error.localizedDescription). Data: \(String(data: data, encoding: .utf8) ?? "non-utf8 data")")
                    completion(.failure(.unexpectedResponse))
                }
            case .failure(let error):
                print("NetworkManager: Failed to add credits: \(error.localizedDescription)")
                completion(.failure(error))
            }
        }
    }

    // MARK: <<< ADDED START >>>
    // Helper function to attempt to extract UserInfo from any data and update UserManager
    private static func tryExtractAndUpdateUserCredits(from data: Data?) {
        guard let data = data else { return }

        // Try to deserialize into a generic [String: Any] to look for "userInfo"
        guard let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
              let userInfoDict = json["userInfo"] as? [String: Any] else {
            // print("NetworkManagerHelper: No 'userInfo' key found at top level or data not JSON dict.")
            return
        }

        // Try to convert userInfoDict back to Data, then decode UserInfo struct
        guard let userInfoData = try? JSONSerialization.data(withJSONObject: userInfoDict, options: []) else {
            // print("NetworkManagerHelper: Could not re-serialize userInfo dictionary to Data.")
            return
        }

        do {
            let decodedUserInfo = try self.jsonDecoder.decode(UserInfo.self, from: userInfoData)
            print("NetworkManagerHelper: Parsed UserInfo. Credits: \(decodedUserInfo.credits) for User: \(decodedUserInfo.appleUserId)")
            UserManager.shared.updateUserCredits(credits: decodedUserInfo.credits)
        } catch {
            // print("NetworkManagerHelper: Failed to decode UserInfo from userInfo dict: \(error.localizedDescription)")
        }
    }
    // MARK: <<< ADDED END >>>
}

extension DateFormatter {
  static let iso8601Full: DateFormatter = {
    let formatter = DateFormatter()
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ" // Format with fractional seconds and timezone
    formatter.calendar = Calendar(identifier: .iso8601)
    formatter.timeZone = TimeZone(secondsFromGMT: 0) // Assume UTC or parse timezone from string
    formatter.locale = Locale(identifier: "en_US_POSIX") // Essential for fixed formats
    return formatter
  }()
}
// MARK: END MODIFIED FILE - Managers/NetworkManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/NetworkManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/PhotoLibraryManager.swift ---
// MARK: ADDED FILE - Managers/PhotoLibraryManager.swift
// File: BrickAI/Managers/PhotoLibraryManager.swift
// Handles downloading (if necessary) and saving images to the Photo Library.

import Foundation
import UIKit
import Photos // Import Photos framework

// Define specific errors for this manager
enum PhotoLibraryError: Error, LocalizedError {
    case invalidURL
    case imageNotFoundOrDownloadFailed
    case photoLibraryAccessDenied
    case saveFailed(Error?) // Optional underlying error from Photos framework

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "The provided image URL was invalid."
        case .imageNotFoundOrDownloadFailed:
            return "Could not retrieve or download the image."
        case .photoLibraryAccessDenied:
            return "Photo Library access denied. Please grant permission in Settings."
        case .saveFailed(let underlying):
            let baseMessage = "Failed to save image to Photo Library."
            if let nsError = underlying as NSError? {
                return "\(baseMessage) Error code: \(nsError.code). \(nsError.localizedDescription)"
            }
            return baseMessage
        }
    }
}

@MainActor // Use MainActor if methods update UI state indirectly (e.g., via @State vars in views)
class PhotoLibraryManager: ObservableObject {

    // Helper object to handle Photo Library save completion
    private lazy var photoLibrarySaver = PhotoLibrarySaveHelper()

    // --- Public API ---

    /// Saves a pre-loaded UIImage directly to the Photo Library.
    /// Handles permission checks.
    func saveImage(_ image: UIImage, completion: @escaping (Result<Void, Error>) -> Void) {
        print("PhotoLibraryManager: Initiating save for pre-loaded image.")
        checkPermissionAndSave(image: image, completion: completion)
    }

    /// Downloads an image from a URL (if not already available) and saves it to the Photo Library.
    /// Handles permission checks.
    func downloadAndSaveImage(url: URL?, imageDataManager: ImageDataManager, completion: @escaping (Result<Void, Error>) -> Void) {
         guard let targetUrl = url else {
             completion(.failure(PhotoLibraryError.invalidURL))
             return
         }
         print("PhotoLibraryManager: Initiating download & save for URL: \(targetUrl.absoluteString)")

         // 1. Check cache via ImageDataManager
         if let cachedImage = imageDataManager.getImage(for: targetUrl) {
              print("PhotoLibraryManager: Image found in cache. Proceeding to save.")
              checkPermissionAndSave(image: cachedImage, completion: completion)
              return
         }

         // 2. Not in cache, attempt download
         print("PhotoLibraryManager: Image not in cache. Attempting download...")
         Task(priority: .userInitiated) { // Use userInitiated priority for responsive save action
             if let downloadedImage = await self.downloadImage(url: targetUrl) {
                 print("PhotoLibraryManager: Download successful. Proceeding to save.")
                 // Also cache the downloaded image
                 imageDataManager.saveImageToCoreData(image: downloadedImage, forKey: targetUrl.absoluteString)
                 // Save to library
                 self.checkPermissionAndSave(image: downloadedImage, completion: completion)
             } else {
                  print("PhotoLibraryManager: Download failed.")
                  completion(.failure(PhotoLibraryError.imageNotFoundOrDownloadFailed))
             }
         }
    }


    // --- Private Helpers ---

    /// Checks Photo Library permission and proceeds to save if authorized.
    private func checkPermissionAndSave(image: UIImage, completion: @escaping (Result<Void, Error>) -> Void) {
        let status = PHPhotoLibrary.authorizationStatus(for: .addOnly)
        switch status {
            case .notDetermined:
                PHPhotoLibrary.requestAuthorization(for: .addOnly) { [weak self] newStatus in
                    if newStatus == .authorized || newStatus == .limited {
                         self?.saveToLibrary(image: image, completion: completion)
                    } else {
                         completion(.failure(PhotoLibraryError.photoLibraryAccessDenied))
                    }
                }
            case .restricted, .denied:
                completion(.failure(PhotoLibraryError.photoLibraryAccessDenied))
            case .authorized, .limited:
                saveToLibrary(image: image, completion: completion)
            @unknown default:
                completion(.failure(PhotoLibraryError.photoLibraryAccessDenied))
        }
    }

    /// Performs the actual save operation using the helper.
    private func saveToLibrary(image: UIImage, completion: @escaping (Result<Void, Error>) -> Void) {
        print("PhotoLibraryManager: Saving image using helper...")
        photoLibrarySaver.saveImage(image, completion: completion)
    }

    /// Downloads a single image from a URL. (Copied basic implementation - could be shared utility)
    private func downloadImage(url: URL) async -> UIImage? {
        do {
            let request = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad) // Use cache if available
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                 print("PhotoLibraryManager: Download failed - Status: \((response as? HTTPURLResponse)?.statusCode ?? 0) for \(url.lastPathComponent)")
                return nil
            }
            guard let image = UIImage(data: data) else {
                 print("PhotoLibraryManager: Failed to create UIImage from data for \(url.lastPathComponent)")
                 return nil
            }
             print("PhotoLibraryManager: Image downloaded successfully from \(url.lastPathComponent).")
            return image
        } catch {
             if (error as? URLError)?.code == .cancelled {
                 print("PhotoLibraryManager: Download cancelled for \(url.lastPathComponent).")
             } else {
                 print("PhotoLibraryManager: Error downloading \(url.lastPathComponent): \(error.localizedDescription)")
             }
            return nil
        }
    }
}

// Helper class to handle the UIImageWriteToSavedPhotosAlbum completion selector
// (Remains the same as before)
private class PhotoLibrarySaveHelper: NSObject {
    private var completionHandler: ((Result<Void, Error>) -> Void)?

    func saveImage(_ image: UIImage, completion: @escaping (Result<Void, Error>) -> Void) {
        self.completionHandler = completion
        UIImageWriteToSavedPhotosAlbum(image, self, #selector(image(_:didFinishSavingWithError:contextInfo:)), nil)
    }

    @objc func image(_ image: UIImage, didFinishSavingWithError error: Error?, contextInfo: UnsafeRawPointer) {
        if let error = error {
             print("PhotoLibrarySaveHelper: Error saving image: \(error.localizedDescription)")
             if (error as NSError).code == PHPhotosError.accessRestricted.rawValue || (error as NSError).code == PHPhotosError.accessUserDenied.rawValue {
                  completionHandler?(.failure(PhotoLibraryError.photoLibraryAccessDenied))
             } else {
                  completionHandler?(.failure(PhotoLibraryError.saveFailed(error)))
             }
        } else {
            print("PhotoLibrarySaveHelper: Image saved successfully.")
            completionHandler?(.success(()))
        }
        completionHandler = nil
    }
}
// MARK: END ADDED FILE - Managers/PhotoLibraryManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/PhotoLibraryManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/StoreManager.swift ---
// MARK: NEW FILE - Managers/StoreManager.swift
// File: BrickAI/Managers/StoreManager.swift
// Manages In-App Purchases using StoreKit.

import Foundation
import StoreKit

// Define a typealias for the completion handler for purchases
typealias PurchaseCompletionHandler = (Result<SKPaymentTransaction, Error>) -> Void

// Define possible errors for the StoreManager
enum StoreError: Error, LocalizedError {
    case failedVerification
    case productNotFound
    case purchaseNotAllowed
    case unknown

    var errorDescription: String? {
        switch self {
        case .failedVerification:
            return "The purchase could not be verified."
        case .productNotFound:
            return "The requested product could not be found."
        case .purchaseNotAllowed:
            return "This device is not allowed to make purchases."
        case .unknown:
            return "An unknown error occurred."
        }
    }
}

@MainActor
class StoreManager: NSObject, ObservableObject {

    // MARK: - Published Properties
    // Holds the products fetched from the App Store
    @Published var products: [SKProduct] = []
    // Tracks the current purchase state (e.g., purchasing, purchased, failed)
    @Published var transactionState: SKPaymentTransactionState?
    // Tracks if products are currently being loaded
    @Published var isLoadingProducts: Bool = false

    // MARK: - Private Properties
    // Set of product identifiers to fetch. This MUST match what's in App Store Connect.
    // For this task, we'll use a placeholder. Replace with your actual Product ID.
// <-----CHANGE START------>
    private let productIdentifiers: Set<String> = [
        "com.NEXTAppDevelopment.brickai.1dollar",
        "com.NEXTAppDevelopment.brickai.5dollars",
        "com.NEXTAppDevelopment.brickai.20dollars"
    ]
// <-----CHANGE END-------->
    
    // Completion handler for the current purchase attempt
    private var onPurchaseCompleted: PurchaseCompletionHandler?

    // MARK: - Initialization
    override init() {
        super.init()
        print("StoreManager: Initializing and preparing to add to payment queue.")
        // Add this class as an observer of the payment queue
        SKPaymentQueue.default().add(self)
        print("StoreManager: Initialized. Self has been added as an observer to SKPaymentQueue.default().")
    }

    deinit {
        // Remove this class as an observer when it's deallocated
        SKPaymentQueue.default().remove(self)
        print("StoreManager: Deinitialized and removed from payment queue.")
    }

    // MARK: - Public Methods

    /// Fetches product information from the App Store.
    func fetchProducts() {
        guard !isLoadingProducts else {
            print("StoreManager: Product fetch already in progress.")
            return
        }
        
        print("StoreManager: Starting to fetch products for identifiers: \(productIdentifiers)")
        isLoadingProducts = true
        transactionState = nil // Reset transaction state

        let request = SKProductsRequest(productIdentifiers: productIdentifiers)
        request.delegate = self
        print("StoreManager: SKProductsRequest created with identifiers: \(productIdentifiers). Starting request...")
        request.start() // This will trigger delegate methods
    }

    /// Initiates a purchase for the given product.
    /// - Parameters:
    ///   - product: The `SKProduct` to purchase.
    ///   - completion: A closure that will be called when the purchase attempt is complete.
    func buyProduct(_ product: SKProduct, completion: @escaping PurchaseCompletionHandler) {
        guard SKPaymentQueue.canMakePayments() else {
            print("StoreManager: Purchases are not allowed on this device.")
            completion(.failure(StoreError.purchaseNotAllowed))
            return
        }

        print("StoreManager: Initiating purchase for product: \(product.productIdentifier)")
        onPurchaseCompleted = completion // Store the completion handler
        transactionState = .purchasing // Update UI state

        let payment = SKPayment(product: product)
        SKPaymentQueue.default().add(payment) // Add payment to the queue
    }
}

// MARK: - SKProductsRequestDelegate
extension StoreManager: SKProductsRequestDelegate {
    /// Called when the product request successfully finishes.
    func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {
        // Update products on the main thread
        DispatchQueue.main.async {
            self.isLoadingProducts = false
// <-----CHANGE START------>
            // Sort products by price to ensure a consistent order if needed
            self.products = response.products.sorted { $0.price.decimalValue < $1.price.decimalValue }
// <-----CHANGE END-------->
            if response.products.isEmpty {
                print("StoreManager: No products found for the given identifiers.")
            } else {
                print("StoreManager: Successfully fetched \(response.products.count) products.")
                response.products.forEach { product in
                    print("StoreManager: - Product ID: \(product.productIdentifier), Price: \(product.localizedPrice ?? "N/A")")
                }
            }
            
            // Log any invalid product identifiers
            if !response.invalidProductIdentifiers.isEmpty {
                print("StoreManager: Invalid product identifiers: \(response.invalidProductIdentifiers)")
            }
        }
    }

    /// Called when the product request fails.
    func request(_ request: SKRequest, didFailWithError error: Error) {
        // Update state on the main thread
        DispatchQueue.main.async {
            self.isLoadingProducts = false
            print("StoreManager: Failed to fetch products: \(error.localizedDescription)")
            // Optionally, you could set an error state here to display to the user
        }
    }
}

// MARK: - SKPaymentTransactionObserver
extension StoreManager: SKPaymentTransactionObserver {
    /// Called when the transaction status updates.
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        for transaction in transactions {
            // Update the published transaction state on the main thread
            DispatchQueue.main.async {
                self.transactionState = transaction.transactionState
            }

            switch transaction.transactionState {
            case .purchasing:
                print("StoreManager: Transaction Purchasing - Product: \(transaction.payment.productIdentifier)")
                // UI is already updated via @Published transactionState
                break
            case .purchased:
                print("StoreManager: Transaction Purchased - Product: \(transaction.payment.productIdentifier)")
                handlePurchased(transaction)
                queue.finishTransaction(transaction) // Important: Finish the transaction
            case .failed:
                print("StoreManager: Transaction Failed - Product: \(transaction.payment.productIdentifier), Error: \(transaction.error?.localizedDescription ?? "No error info")")
                handleFailed(transaction)
                queue.finishTransaction(transaction) // Important: Finish the transaction
            case .restored:
                print("StoreManager: Transaction Restored - Product: \(transaction.payment.productIdentifier)")
                // Handle restored purchases (e.g., for non-consumables or subscriptions)
                // For consumables, this might not grant the item again but good to acknowledge.
                // For simplicity in this initial version for a consumable, we'll just finish it.
                queue.finishTransaction(transaction)
            case .deferred:
                print("StoreManager: Transaction Deferred - Product: \(transaction.payment.productIdentifier)")
                // The transaction is in the queue, but its final status is pending external action (e.g., Ask to Buy)
                // UI should inform the user that the purchase is waiting for approval.
                onPurchaseCompleted?(.failure(transaction.error ?? StoreError.unknown)) // Notify of deferred state
                // Do not finish the transaction yet.
            @unknown default:
                print("StoreManager: Unknown transaction state.")
                queue.finishTransaction(transaction) // Finish unknown states to prevent queue blockage
                onPurchaseCompleted?(.failure(StoreError.unknown))
            }
        }
    }

    /// Optional: Called when transactions are removed from the queue (e.g., after `finishTransaction`).
    func paymentQueue(_ queue: SKPaymentQueue, removedTransactions transactions: [SKPaymentTransaction]) {
        print("StoreManager: \(transactions.count) transaction(s) removed from the queue.")
        transactions.forEach { transaction in
            print("StoreManager: - Removed transaction for product: \(transaction.payment.productIdentifier)")
        }
    }

    /// Optional: Called when an error occurs while restoring purchases.
    func paymentQueue(_ queue: SKPaymentQueue, restoreCompletedTransactionsFailedWithError error: Error) {
        print("StoreManager: Restore completed transactions failed with error: \(error.localizedDescription)")
        // Update UI to inform the user about the failure
    }

    /// Optional: Called when all restorable purchases have been processed.
    func paymentQueueRestoreCompletedTransactionsFinished(_ queue: SKPaymentQueue) {
        print("StoreManager: Payment queue restore completed transactions finished.")
        // Update UI if needed
        if queue.transactions.isEmpty {
            print("StoreManager: No transactions were restored.")
        }
    }
    
    // MARK: - Private Helper Methods

    /// Handles a successfully purchased transaction.
    private func handlePurchased(_ transaction: SKPaymentTransaction) {
        print("StoreManager: Handling purchased transaction for \(transaction.payment.productIdentifier)")
        
        // --- IMPORTANT: Grant Content/Update User State VIA BACKEND ---
        let productId = transaction.payment.productIdentifier
        print("StoreManager: Calling NetworkManager to add credits for product ID: \(productId)")

        NetworkManager.addCreditsForPurchase(productId: productId) { result in
            // This completion handler is called on the main thread by NetworkManager
            switch result {
            case .success(let newTotalCredits):
                print("StoreManager: Successfully updated credits via backend. New total: \(newTotalCredits).")
                // Here you could update a local user model or trigger UI updates based on the new credit total
                // For example: UserManager.shared.updateLocalCredits(newTotalCredits)
                // Notify the purchase completion handler AFTER successful backend update
                self.onPurchaseCompleted?(.success(transaction))
            case .failure(let error):
                print("StoreManager: Failed to update credits via backend for product ID \(productId). Error: \(error.localizedDescription)")
                // Handle the error appropriately. 
                // For now, we still call the purchase completion with success for the transaction itself,
                // as the App Store purchase was successful. The backend sync failed.
                // You might want a more sophisticated error handling strategy here, e.g., 
                // retry mechanism, or informing the user that the purchase was made but credits update failed.
                // Depending on the error type, you might also consider not fulfilling the purchase locally
                // if backend sync is critical.
                // For now, let's assume the purchase is valid and we'll complete it, but log the backend error.
                self.onPurchaseCompleted?(.success(transaction)) // Or .failure(error) if you want to signify the overall operation failed
            }
            self.onPurchaseCompleted = nil // Reset for next purchase (moved here to ensure it's called in both success/failure paths)
        }
        // --- OLD Grant Content/Update User State (Conceptual) ---
        // This is where you would:
        // 1. Verify the receipt (ideally server-side, but can be client-side for simplicity initially).
        // 2. If verified, unlock the content or update the user's "tries".
        // For example, if productIdentifier == "com.yourapp.30tries", add 30 to user's tries.
        //
        // Example (conceptual - actual update mechanism depends on your UserManager/data model):
        // if transaction.payment.productIdentifier == "com.yourapp.30tries" {
        //     UserManager.shared.addTries(30) // You'll need to implement this
        //     print("StoreManager: 30 tries granted to the user.")
        // }
        // ---
    }

    /// Handles a failed transaction.
    private func handleFailed(_ transaction: SKPaymentTransaction) {
        print("StoreManager: Handling failed transaction for \(transaction.payment.productIdentifier)")
        var errorToReport: Error = StoreError.unknown
        if let error = transaction.error as? SKError {
            // More specific SKError handling
            if error.code == .paymentCancelled {
                print("StoreManager: Payment cancelled by user.")
                // No need to show a generic error if user cancelled.
                // The UI should ideally just return to its previous state.
                // For the completion handler, we still signal a failure but can be specific.
                errorToReport = error // Pass the SKError itself
            } else {
                print("StoreManager: SKError code: \(error.code.rawValue) - \(error.localizedDescription)")
                errorToReport = error // Pass the SKError
            }
        } else if let error = transaction.error {
            print("StoreManager: Generic transaction error: \(error.localizedDescription)")
            errorToReport = error // Pass the generic Error
        }
        
        onPurchaseCompleted?(.failure(errorToReport))
        onPurchaseCompleted = nil // Reset for next purchase
    }
}

// Helper to format price
extension SKProduct {
    var localizedPrice: String? {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = priceLocale
        return formatter.string(from: price)
    }
}
--- File End: ios-app/BrickAI/BrickAI/Managers/StoreManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/UserManager.swift ---
// MARK: MODIFIED FILE - Managers/UserManager.swift
// File: BrickAI/Managers/UserManager.swift
// Removed direct dependency on ImageDataManager

import Foundation
import Combine

class UserManager: ObservableObject {
    static let shared = UserManager() // Keep as singleton for easy access if needed elsewhere, but LoginView uses EnvironmentObject

    @Published private(set) var userName: String?
    @Published private(set) var userIdentifier: String?
    @Published private(set) var isLoggedIn: Bool = false
    @Published private(set) var userCredits: Int?

    private init() {
        self.userIdentifier = KeychainService.loadString(forKey: kKeychainAccountUserIdentifier)
        self.userName = KeychainService.loadString(forKey: kKeychainAccountUserName)
        let sessionToken = KeychainService.loadString(forKey: kKeychainAccountSessionToken)
        self.isLoggedIn = (self.userIdentifier != nil && !self.userIdentifier!.isEmpty && sessionToken != nil && !sessionToken!.isEmpty)
        self.userCredits = nil
        print("UserManager Initialized. UserIdentifier loaded: \(self.userIdentifier != nil), UserName loaded: \(self.userName != nil), SessionToken loaded: \(sessionToken != nil). Determined isLoggedIn: \(self.isLoggedIn), Credits: \(self.userCredits == nil ? "nil" : String(self.userCredits!))")
    }

    // Save initial credentials and session token
    func saveCredentials(userName: String?, userIdentifier: String, sessionToken: String) {
        do {
            try KeychainService.saveString(userIdentifier, forKey: kKeychainAccountUserIdentifier)
            if let name = userName, !name.isEmpty {
                try KeychainService.saveString(name, forKey: kKeychainAccountUserName)
            } else {
                try? KeychainService.deleteData(forKey: kKeychainAccountUserName)
            }
            try KeychainService.saveString(sessionToken, forKey: kKeychainAccountSessionToken)

            DispatchQueue.main.async {
                self.userIdentifier = userIdentifier
                self.userName = userName
                self.isLoggedIn = true
                print("UserManager: Credentials and session token saved successfully. isLoggedIn set to true.")
            }
        } catch {
            print("UserManager: Failed to save credentials/session token to Keychain: \(error.localizedDescription)")
            DispatchQueue.main.async { self.clearUser() }
        }
    }

    // Retrieve the current backend session token (Unchanged)
    func getSessionToken() -> String? {
        do {
            guard let tokenString = KeychainService.loadString(forKey: kKeychainAccountSessionToken) else {
                throw KeychainError.itemNotFound
            }
            return tokenString
        } catch KeychainError.itemNotFound {
            print("UserManager: Backend session token not found in Keychain.")
            return nil
        } catch {
            print("UserManager: Failed to load backend session token from Keychain: \(error.localizedDescription)")
            return nil
        }
    }

    // Update only the session token after a refresh (Unchanged)
    func updateSessionToken(newToken: String) {
        do {
            try KeychainService.saveString(newToken, forKey: kKeychainAccountSessionToken)
            print("UserManager: Session token updated successfully in Keychain.")
            if !self.isLoggedIn {
                DispatchQueue.main.async {
                    self.userIdentifier = KeychainService.loadString(forKey: kKeychainAccountUserIdentifier)
                    self.isLoggedIn = (self.userIdentifier != nil && !self.userIdentifier!.isEmpty)
                    print("UserManager: Warning - isLoggedIn was false during token update. Resetting based on user ID presence.")
                }
            }
        } catch {
            print("UserManager: Failed to update session token in Keychain: \(error.localizedDescription)")
        }
    }

    // Clear user data and session token
    func clearUser() {
        try? KeychainService.deleteData(forKey: kKeychainAccountUserIdentifier)
        try? KeychainService.deleteData(forKey: kKeychainAccountSessionToken)
        try? KeychainService.deleteData(forKey: kKeychainAccountUserName)

        DispatchQueue.main.async {
            self.userIdentifier = nil
            self.userName = nil
            self.isLoggedIn = false
            self.userCredits = nil
            print("UserManager: User data and session token cleared from Keychain and state updated. isLoggedIn set to false.")
        }
    }

    // Function to delete the current user's account
    func deleteCurrentUserAccount(completion: @escaping (Result<Void, NetworkError>) -> Void) {
        print("UserManager: Attempting to delete current user account.")
        NetworkManager.deleteAccount { [weak self] result in
            guard let self = self else { return }

            DispatchQueue.main.async {
                switch result {
                case .success:
                    print("UserManager: Account deletion successful via NetworkManager. Clearing local user data.")
                    self.clearUser() // Clear local user credentials and state
                    completion(.success(()))
                case .failure(let error):
                    print("UserManager: Account deletion failed: \(error.localizedDescription)")
                    completion(.failure(error))
                }
            }
        }
    }

    // Function to update user credits
    func updateUserCredits(credits: Int) {
        DispatchQueue.main.async {
            self.userCredits = credits
            print("UserManager: User credits updated to \(credits)")
        }
    }
}
// MARK: END MODIFIED FILE - Managers/UserManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/UserManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Models/ImageData.swift ---
// File: BrickAI/Models/ImageData.swift
// Modified CodingKeys to expect camelCase JSON from backend

import Foundation

struct ImageData: Codable, Identifiable {
    let id: Int // Matches SERIAL PK
    let status: String
    let prompt: String?
    let createdAt: Date
    let originalImageUrl: URL?
    let processedImageUrl: URL?

    // Coding keys to match JSON *sent by the backend*.
    // If backend sends camelCase (e.g., 'createdAt'), list case without explicit string value.
    // If backend sends snake_case (e.g., 'created_at'), map it like `case propertyName = "json_key"`.
    enum CodingKeys: String, CodingKey {
        case id // Assumes backend sends 'id'
        case status // Assumes backend sends 'status'
        case prompt // Assumes backend sends 'prompt'

        // Adjust these to match the keys ACTUALLY being sent by your /api/images backend:
        // Assuming backend sends camelCase as per its internal mapping object:
        case createdAt
        case originalImageUrl
        case processedImageUrl

        // If backend was sending snake_case (like the corrected version I sent before), you would use:
        // case createdAt = "created_at"
        // case originalImageUrl = "original_image_url"
        // case processedImageUrl = "processed_image_url"
    }
}

// Example for PreviewProvider (remains the same structure, uses Int ID)
extension ImageData {
    static var previewData: [ImageData] {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return [
            ImageData(id: 1, status: "COMPLETED", prompt: "A cat made of bricks", createdAt: Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/0000FF/808080?text=Original+1"), processedImageUrl: URL(string: "https://via.placeholder.com/150/FF0000/FFFFFF?text=Processed+1")),
            ImageData(id: 2, status: "UPLOADED", prompt: "A dog made of bricks", createdAt: formatter.date(from: "2025-04-05T10:30:00.123Z") ?? Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/00FF00/808080?text=Original+2"), processedImageUrl: nil),
            ImageData(id: 3, status: "FAILED", prompt: "A house made of bricks", createdAt: formatter.date(from: "2025-04-04T15:00:00Z") ?? Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/FFFF00/808080?text=Original+3"), processedImageUrl: nil)
        ]
    }
}

--- File End: ios-app/BrickAI/BrickAI/Models/ImageData.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Models/PendingUploadInfo.swift ---
// MARK: NEW FILE - Models/PendingUploadInfo.swift
// File: BrickAI/Models/PendingUploadInfo.swift
// Represents an image upload that is pending confirmation from the backend.

import Foundation
import SwiftUI // For Identifiable, UIImage

//<-----CHANGE START------>
// Made properties non-optional for simpler dummy row display initially
// Added placeholder for thumbnail data
struct PendingUploadInfo: Identifiable {
    let id: UUID // Use the client-generated UUID for identity
    let placeholderImageName: String = "hourglass.circle" // System icon for pending
    let createdAt: Date // Time the pending upload was initiated

    // Simple initializer
    init(id: UUID = UUID(), createdAt: Date = Date()) {
        self.id = id
        self.createdAt = createdAt
    }
}
//<-----CHANGE END-------->
// MARK: END NEW FILE - Models/PendingUploadInfo.swift
--- File End: ios-app/BrickAI/BrickAI/Models/PendingUploadInfo.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/CameraLiveView.swift ---
import SwiftUI
import AVFoundation

// Renamed Struct
struct CameraLiveView: UIViewRepresentable {
    let session: AVCaptureSession
     
    func makeUIView(context: Context) -> PreviewView {
        let view = PreviewView()
        view.session = session
        // Ensure the view's frame fills the available space
        view.setContentHuggingPriority(.defaultLow, for: .horizontal)
        view.setContentHuggingPriority(.defaultLow, for: .vertical)
        return view
    }
     
    func updateUIView(_ uiView: PreviewView, context: Context) {
        // If the session changes, update the preview view
        if uiView.session != session {
             uiView.session = session
        }
    }
     
    // Custom UIView subclass remains the same internally
    class PreviewView: UIView {
        var session: AVCaptureSession? {
            didSet {
                guard let session = session else {
                    previewLayer.session = nil
                    return
                }
                // Check if the layer's session needs updating
                 if previewLayer.session != session {
                    previewLayer.session = session
                 }
            }
        }
         
        // The AVCaptureVideoPreviewLayer displays the camera feed.
        // Make it lazy to ensure layerClass is used.
        lazy var previewLayer: AVCaptureVideoPreviewLayer = {
             let layer = AVCaptureVideoPreviewLayer()
             layer.videoGravity = .resizeAspectFill // Fill the layer bounds
             // Set the connection's orientation later in layoutSubviews or updateOrientation
             return layer
         }()


        // Override layerClass to ensure the view's backing layer is a AVCaptureVideoPreviewLayer
        // This is often considered cleaner than adding a sublayer manually.
        // override class var layerClass: AnyClass {
        //     AVCaptureVideoPreviewLayer.self
        // }
        // Note: If using layerClass override, access the layer via `self.layer as! AVCaptureVideoPreviewLayer`.
        // The current sublayer approach is also common and works fine. Let's stick to it for consistency.

         
        override init(frame: CGRect) {
            super.init(frame: frame)
            setupPreviewLayer()
        }
         
        required init?(coder: NSCoder) {
            super.init(coder: coder)
            setupPreviewLayer()
        }
         
        private func setupPreviewLayer() {
            // If NOT using layerClass override, add the previewLayer as a sublayer
             previewLayer.videoGravity = .resizeAspectFill
             layer.addSublayer(previewLayer)
        }
         
        override func layoutSubviews() {
            super.layoutSubviews()
            // Ensure the preview layer always fills the view's bounds
            previewLayer.frame = bounds
            updateOrientation() // Update orientation whenever layout changes
        }
         
        // Update preview orientation based on interface orientation
        private func updateOrientation() {
             guard let connection = previewLayer.connection, connection.isVideoOrientationSupported else { return }
             
             // Get current interface orientation
             // Note: Using UIDevice.current.orientation can be unreliable as it might report faceUp/faceDown.
             // It's often better to use the scene's interface orientation.
             let interfaceOrientation = window?.windowScene?.interfaceOrientation ?? .portrait // Default to portrait

             let videoOrientation: AVCaptureVideoOrientation
             switch interfaceOrientation {
             case .portrait:
                 videoOrientation = .portrait
             case .landscapeLeft:
                 videoOrientation = .landscapeLeft // Map directly
             case .landscapeRight:
                 videoOrientation = .landscapeRight // Map directly
             case .portraitUpsideDown:
                 videoOrientation = .portraitUpsideDown
             case .unknown:
                  videoOrientation = .portrait // Fallback
             @unknown default:
                 videoOrientation = .portrait // Fallback
             }
             
             if connection.videoOrientation != videoOrientation {
                  connection.videoOrientation = videoOrientation
             }
        }
    }
}

--- File End: ios-app/BrickAI/BrickAI/Views/CameraLiveView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/CapturedImageView.swift ---
// MARK: MODIFIED FILE - Views/CapturedImageView.swift
// File: BrickAI/Views/CapturedImageView.swift
// Modified upload action to be asynchronous and immediately dismiss the view.
// Added call to ImageDataManager to enqueue pending upload.
// Update ImageDataManager's lastUploadSuccessTime on successful upload.
// <-----CHANGE START------>
// Moved update of lastUploadSuccessTime to trigger immediately before upload starts.
// Added image resizing to reduce file size before upload.
// <-----CHANGE END-------->


import SwiftUI

struct CapturedImageView: View {
    let image: UIImage // The captured image to display/upload
    let isSelfie: Bool // Added to know if the image was from front camera
    let isFromCameraRoll: Bool // Added to know if the image was from camera roll

    @StateObject private var cameraManager = CameraManager.shared
    @EnvironmentObject var imageDataManager: ImageDataManager
    @EnvironmentObject var userManager: UserManager

    // State variables for credit check and navigation to PaymentsView
    @State private var showInsufficientCreditsAlert = false
    @State private var presentPaymentsView = false

    var body: some View {
        ZStack {
            // Background
            Color.black.ignoresSafeArea()

            // Display the captured image
            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: isFromCameraRoll ? .fit : .fill)
                .scaleEffect(x: (!isFromCameraRoll && isSelfie) ? -1 : 1, y: 1)
                .ignoresSafeArea()

            // Overlays for controls
            VStack {
                 // Top row with Cancel ('X') button
                 HStack {
                    Spacer()
                    Button(action: {
                        // Allow cancelling
                        cameraManager.resetCaptureState() // Dismiss this view by resetting state
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title)
                            .padding()
                            .foregroundColor(.white)
                            .shadow(radius: 3)
                    }
                    .padding() // Keep padding for the button itself
                    Spacer().frame(width: 300)
                    Spacer() // This Spacer pushes the button to the left
                 }

                 Spacer() // Pushes bottom controls down

                 // Bottom row with Confirm (Checkmark) button
                 HStack(spacing: 60) {
                     Spacer()
                     Button(action: handleConfirmAction) {
                         Text("Create!")
                             .font(.system(size: 24, weight: .bold))
                             .foregroundColor(.white)
                             .padding(.horizontal, 40)
                             .padding(.vertical, 15)
                             .background(Color.blue)
                             .cornerRadius(30)
                             .shadow(radius: 5)
                     }
                     // Button is never disabled as action is now instantaneous
                     Spacer()
                 }
                 .padding(.bottom, 30)

                 // Removed Status Message Area - View dismisses before showing status

            }
        }
        .onAppear {
            print("CapturedImageView: Appeared.")
        }
        // Alert for insufficient credits
        .alert("Insufficient Credits", isPresented: $showInsufficientCreditsAlert) {
            Button("Purchase Credits") {
                self.presentPaymentsView = true
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("You don't have enough credits to upload an image. Please purchase more to continue.")
        }
        // Sheet to present PaymentsView
        .sheet(isPresented: $presentPaymentsView) {
            // Ensure PaymentsView gets its necessary environment objects if any
            // (it will inherit from CapturedImageView's environment)
            PaymentsView()
        }
    }
    
    // MARK: - Action Handlers
    private func handleConfirmAction() {
        // Check for sufficient credits BEFORE any other action
        guard let credits = userManager.userCredits, credits > 0 else {
            print("CapturedImageView: Insufficient credits (\(userManager.userCredits ?? 0)). Showing alert.")
            self.showInsufficientCreditsAlert = true
            return // Stop further processing
        }
        
        // If credits are sufficient, proceed with upload logic:

        // 0. Add to pending queue BEFORE dismissing/uploading
        print("CapturedImageView: Adding image to pending queue.")
        imageDataManager.addImageToPendingQueue()

        // 1. Immediately dismiss the view / reset camera state
        print("CapturedImageView: Confirm tapped. Dismissing view immediately.")
        cameraManager.resetCaptureState()

        // 1.5 Update success timestamp HERE to trigger popup immediately
        Task { @MainActor in // Ensure update is on main actor
            imageDataManager.lastUploadSuccessTime = Date()
            print("CapturedImageView: Updated lastUploadSuccessTime to trigger popup NOW.")
        }

        // 2. Launch the upload in a background Task
        print("CapturedImageView: Launching upload task in background.")
        Task(priority: .background) {
            // Keep a copy of the image data for the background task
            let imageToUpload = self.image
            
            // Resize the image before uploading to reduce file size
            let resizedImage = resizeImage(imageToUpload)
            print("CapturedImageView: Resized image for upload. Original size: \(imageToUpload.size), New size: \(resizedImage.size)")

            // Call NetworkManager's uploadImage function.
            NetworkManager.uploadImage(resizedImage) { result in
                // This completion handler still runs on the main thread when the upload finishes
                switch result {
                case .success(let urlString):
                    // Upload finished successfully in the background
                    print("CapturedImageView (Background Task): Upload Successful! URL: \(urlString)")
                    // REMOVED timestamp update from here
                    // NOTE: Polling should eventually reflect this, manual refresh might not be needed.

                case .failure(let error):
                    // Upload failed in the background
                    print("CapturedImageView (Background Task): Upload Failed: \(error.localizedDescription)")
                    // Optional: Log error, potentially notify user via a different mechanism if needed
                    if case .authenticationTokenMissing = error {
                         print("CapturedImageView (Background Task): Handling authenticationTokenMissing error.")
                    } else if case .unauthorized = error {
                         print("CapturedImageView (Background Task): Handling unauthorized error (session expired?).")
                    }
                    // Consider removing from pending queue if upload fails permanently?
                    // This is tricky, as a retry might happen. Current logic relies on backend acknowledgement.
                }
            }
        }
        // --- End launching background task ---
    }

    // Resize and compress the image to reduce file size
    private func resizeImage(_ image: UIImage) -> UIImage {
        let maxDimension: CGFloat = 1200 // Maximum width/height (adjust as needed)
        let compressionQuality: CGFloat = 0.7 // JPEG compression quality (0.0-1.0)
        
        // Calculate scaling factor to maintain aspect ratio
        let originalSize = image.size
        var newSize = originalSize
        
        if originalSize.width > maxDimension || originalSize.height > maxDimension {
            let widthRatio = maxDimension / originalSize.width
            let heightRatio = maxDimension / originalSize.height
            let ratio = min(widthRatio, heightRatio)
            
            newSize = CGSize(width: originalSize.width * ratio, height: originalSize.height * ratio)
        } else {
            // No resizing needed if already small enough
            return compressImage(image, compressionQuality: compressionQuality)
        }
        
        // Render the resized image
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext() ?? image
        UIGraphicsEndImageContext()
        
        // Apply JPEG compression to the resized image
        return compressImage(resizedImage, compressionQuality: compressionQuality)
    }
    
    // Compress image using JPEG compression
    private func compressImage(_ image: UIImage, compressionQuality: CGFloat) -> UIImage {
        guard let imageData = image.jpegData(compressionQuality: compressionQuality),
              let compressedImage = UIImage(data: imageData) else {
            return image // Return original if compression fails
        }
        return compressedImage
    }
}

// MARK: END MODIFIED FILE - Views/CapturedImageView.swift

--- File End: ios-app/BrickAI/BrickAI/Views/CapturedImageView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/HomeView.swift ---
// MARK: MODIFIED FILE - Views/HomeView.swift
// Changed settings button icon to person.circle.fill and made it more unassuming.
// Added camera switch button
// Added success popup notification triggered by ImageDataManager.
// Removed internal UploadSuccessPopup definition and use UploadSuccessPopupView from separate file.
// <-----CHANGE START------>
// Added notification badge to Image List button showing actively processing count.
// Added Usages/Payments Icon Button to top-left.
// <-----CHANGE END-------->


import SwiftUI
import AVFoundation
import PhotosUI

struct HomeView: View {
    // Access shared managers
    @StateObject private var cameraManager = CameraManager.shared
    @EnvironmentObject var userManager: UserManager // Assuming provided by parent (e.g., LoginView)
    // Access ImageDataManager to monitor upload success and processing count
    @EnvironmentObject var imageDataManager: ImageDataManager
    // State to control the success popup visibility
    @State private var showSuccessPopup = false
    // Store the task responsible for hiding the popup to allow cancellation
    @State private var hidePopupTask: Task<Void, Never>? = nil
    // State to manage photo selection from library
    @State private var photoPickerItem: PhotosPickerItem?
    @State private var showPhotoPicker = false
    @State private var showPaymentsSheet = false // <<< ADDED: State for presenting PaymentsView as a sheet
    @State private var isCurrentImageFromCameraRoll: Bool = false // ADDED: To track image source


    var body: some View {
         // Use NavigationStack for modern navigation features
         NavigationStack {
             ZStack {
                 // --- Main Content Area ---
                 if cameraManager.isPermissionGranted {
                      // --- Camera Granted Flow ---
                      if let capturedImage = cameraManager.capturedImage {
                          // --- Show Captured Image View ---
                           CapturedImageView(image: capturedImage,
                                             isSelfie: cameraManager.isFrontCameraActive,
                                             isFromCameraRoll: isCurrentImageFromCameraRoll)
                               .environmentObject(imageDataManager) // Pass manager down
                               .transition(.asymmetric(insertion: .move(edge: .trailing), removal: .identity))
                      } else {
                           // --- Show Camera Preview and Controls ---
                           // Group the CameraLiveView and its specific overlays
                           ZStack {
                               CameraLiveView(session: cameraManager.session)
                                    .ignoresSafeArea()
                                    .transition(.identity)

                               // Overlays directly related to CameraLiveView
                               VStack {
                                   // Top Spacer (pushes content down)
                                   Spacer()

                                   // Bottom Controls Row
                                   HStack(alignment: .bottom) {
                                       // Gallery Button
                                       Button(action: {
                                           showPhotoPicker = true
                                       }) {
                                           Image(systemName: "photo.on.rectangle")
                                               .font(.title2)
                                               .foregroundColor(.white)
                                               .padding()
                                               .background(Color.black.opacity(0.5))
                                               .clipShape(Circle())
                                       }
                                       .padding(.leading)

                                       Spacer() // Center the new VStack

                                       //<-----CHANGE START------>
                                       // VStack for Capture Button and Switch Camera Button
                                       VStack(spacing: 15) { // Add spacing between buttons
                                           // Camera Switch Button (smaller)
                                           Button(action: cameraManager.switchCamera) {
                                               Image(systemName: "arrow.triangle.2.circlepath.camera")
                                                   .font(.title3) // Smaller icon
                                                   .foregroundColor(.white)
                                                   .padding(10) // Smaller padding
                                                   .background(Color.black.opacity(0.5))
                                                   .clipShape(Circle())
                                           }

                                           // Capture Button
                                           Button(action: cameraManager.capturePhoto) {
                                                ZStack {
                                                    Circle().fill(.white).frame(width: 65, height: 65)
                                                    Circle().stroke(.white, lineWidth: 2).frame(width: 75, height: 75)
                                                }
                                                .shadow(radius: 5)
                                           }
                                       }
                                       //<-----CHANGE END-------->

                                       Spacer() // Right align list button

                                       // --- Image List Button with Badge ---
                                       NavigationLink(destination: ImageListView()) {
                                            ZStack(alignment: .topTrailing) { // Use ZStack for badge positioning
                                                // Base Button Content
                                                Image(systemName: "photo.stack")
                                                    .font(.title2)
                                                    .foregroundColor(.white)
                                                    .padding() // Padding for the icon itself
                                                    .background(Color.black.opacity(0.5))
                                                    .clipShape(Circle())

                                                // Badge Overlay (only if count > 0)
                                                if imageDataManager.activelyProcessingCount > 0 {
                                                     Text("\(imageDataManager.activelyProcessingCount)")
                                                         .font(.caption2.bold())
                                                         .foregroundColor(.white)
                                                         .padding(5) // Padding inside the circle
                                                         .background(Color.red)
                                                         .clipShape(Circle())
                                                         // Offset the badge slightly
                                                         .offset(x: 5, y: -5)
                                                }
                                            }
                                        }
                                        .padding(.trailing)

                                   } // End HStack for bottom controls
                                   .padding(.bottom, 40) // Padding from bottom edge

                               } // End VStack for bottom controls layout

                               // --- Upload Success Popup Overlay ---
                               // Added overlay within the ZStack containing CameraLiveView
                               VStack {
                                    if showSuccessPopup {
                                        // Use the new view from the separate file
                                        UploadSuccessPopupView()
                                             .transition(.move(edge: .top).combined(with: .opacity))
                                             .onAppear {
                                                 // Cancel any existing hide task before starting a new one
                                                 hidePopupTask?.cancel()
                                                 // Schedule task to hide popup after delay
                                                 hidePopupTask = Task {
                                                      do {
                                                          // Wait for 2 seconds (adjust duration if needed)
                                                          try await Task.sleep(nanoseconds: 2_000_000_000)
                                                          // Hide the popup if the task wasn't cancelled
                                                          withAnimation {
                                                              showSuccessPopup = false
                                                          }
                                                          print("HomeView: Hiding success popup after delay.")
                                                      } catch {
                                                          // Handle cancellation (e.g., if view disappears or another upload happens quickly)
                                                          print("HomeView: Hide popup task cancelled.")
                                                      }
                                                 }
                                             }
                                    }
                                    Spacer() // Pushes popup to the top
                               }
                               .padding(.top, 20) // Padding from the very top safe area edge
                               // Use default animation for showing/hiding container, new view has internal animation
                               .animation(.default, value: showSuccessPopup)


                           } // End ZStack for CameraLiveView + overlays
                            // <-----CHANGE START------>
                            // --- Top Left: Usages/Payments Icon ---
                            .overlay(alignment: .topLeading) {
                                // Changed NavigationLink to Button to present as a sheet
                                Button(action: {
                                    showPaymentsSheet = true // Set state to true to show the sheet
                                }) {
                                    HStack(spacing: 4) {
                                        Image(systemName: "bolt.fill")
                                            .foregroundColor(.blue)
                                        Text("\(userManager.userCredits ?? -1)") // Display -1 if nil, for debugging or placeholder
                                            .font(.callout)
                                            .fontWeight(.medium)
                                            .foregroundColor(.primary)
                                    }
                                    .padding(.horizontal, 10)
                                    .padding(.vertical, 6)
                                    .background(Color(.white).opacity(0.5))
                                    .cornerRadius(20) // Capsule shape
                                }
                                .padding([.top, .leading], 16)
                            }
                            // <-----CHANGE END-------->
                           // --- Top Right: Settings Button Overlay ---
                            .overlay(alignment: .topTrailing) {
                                NavigationLink(destination: UserInfoView()) {
                                       Image(systemName: "person.circle.fill")
                                            .font(.title)
                                            .foregroundColor(.white.opacity(0.8))
                                  }
                                  .padding([.top, .trailing], 16)
                            }


                      } // End else (show camera preview)
                 } else {
                      // --- Show No Permission View ---
                       NoAccessView(onRequestPermission: cameraManager.requestCameraPermission)
                       .transition(.opacity)
                 } // End if permissionGranted

             } // End ZStack
             // --- View Modifiers ---
              .navigationBarHidden(true)
              .statusBar(hidden: true)
              .photosPicker(isPresented: $showPhotoPicker, selection: $photoPickerItem, matching: .images, preferredItemEncoding: .current)
              .onChange(of: photoPickerItem) { oldValue, newValue in
                  if let item = newValue {
                      Task {
                          if let data = try? await item.loadTransferable(type: Data.self),
                             let uiImage = UIImage(data: data) {
                              await MainActor.run {
                                  self.isCurrentImageFromCameraRoll = true // ADDED: Set flag for camera roll image
                                  cameraManager.capturedImage = uiImage
                                  photoPickerItem = nil
                              }
                          }
                      }
                  }
              }
              .onAppear {
                  print("HomeView: Appeared.")
                  cameraManager.checkCameraPermission()
                  if cameraManager.isPermissionGranted && cameraManager.capturedImage == nil {
                       cameraManager.startSession()
                  }
              }
              .onDisappear {
                   print("HomeView: Disappeared.")
                   cameraManager.stopSession()
                   // Cancel hide popup task if view disappears
                   hidePopupTask?.cancel()
              }
              .onChange(of: cameraManager.capturedImage) { oldImage, newImage in
                   if newImage != nil {
                       print("HomeView: Image captured, stopping session.")
                       cameraManager.stopSession()
                   } else {
                       print("HomeView: Captured image cleared.")
                       self.isCurrentImageFromCameraRoll = false // ADDED: Reset flag when image is cleared
                       if cameraManager.isPermissionGranted {
                            print("HomeView: Starting session after image clear.")
                            cameraManager.startSession()
                       }
                   }
              }
              .onChange(of: cameraManager.isPermissionGranted) { oldPermission, newPermission in
                   if newPermission {
                        if cameraManager.capturedImage == nil && !cameraManager.session.isRunning {
                             print("HomeView: Permission granted, starting session.")
                             cameraManager.startSession()
                        }
                   } else {
                         print("HomeView: Permission revoked/denied, stopping session.")
                        cameraManager.stopSession()
                   }
              }
              .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
                   print("HomeView: App will enter foreground, rechecking permission.")
                   cameraManager.checkCameraPermission()
              }
              // --- Listener for Upload Success ---
              .onChange(of: imageDataManager.lastUploadSuccessTime) { _, newValue in
                   // Trigger popup only if the new value is non-nil
                   // (We don't need to compare old/new, just react to the latest success)
                   if newValue != nil {
                       print("HomeView: Detected new upload success time. Showing popup.")
                       // Use default animation here, the view inside animates itself
                       withAnimation {
                           showSuccessPopup = true
                       }
                       // The .onAppear modifier of the popup itself handles the timer to hide it.
                   }
              }
              // --- Sheet for PaymentsView ---
              .sheet(isPresented: $showPaymentsSheet) { // <<< ADDED: Sheet modifier
                  PaymentsView()
                    // PaymentsView will inherit necessary EnvironmentObjects like storeManager and userManager
              }
         } // End NavigationStack
    } // End body
}


// --- NoAccessView (Unchanged) ---
struct NoAccessView: View {
     var onRequestPermission: () -> Void

     var body: some View {
         VStack(spacing: 15) {
             Spacer()
             Image(systemName: "camera.fill")
                 .font(.system(size: 60)).foregroundColor(.secondary).padding(.bottom, 10)
             Text("Camera Access Required").font(.title2).fontWeight(.semibold)
             Text("Enable camera access in Settings to capture photos.")
                 .font(.subheadline).foregroundColor(.gray).multilineTextAlignment(.center).padding(.horizontal, 40)
             Button("Continue", action: onRequestPermission)
                  .padding(.vertical, 10).padding(.horizontal, 20).background(Color.blue).foregroundColor(.white).cornerRadius(8).padding(.top)
             Button("Open App Settings") { if let url = URL(string: UIApplication.openSettingsURLString) { UIApplication.shared.open(url) }}
                 .font(.footnote).padding(.top, 5)
             Spacer()
         }
         .frame(maxWidth: .infinity, maxHeight: .infinity)
         .background(Color(.systemBackground))
     }
}

// MARK: END MODIFIED FILE - Views/HomeView.swift

--- File End: ios-app/BrickAI/BrickAI/Views/HomeView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/EmptyListView.swift ---
// MARK: ADDED FILE - Views/ImageList/EmptyListView.swift
// File: BrickAI/Views/ImageList/EmptyListView.swift
// Simple view for the empty list state (no images uploaded yet)

import SwiftUI

struct EmptyListView: View {
    var body: some View {
        Text("You haven't uploaded any images yet.")
            .font(.title3) // Slightly larger text
// <-----CHANGE START------>
            .foregroundColor(Color(UIColor.systemGray3)) // Adjusted for black background
// <-----CHANGE END-------->
            .frame(maxWidth: .infinity, maxHeight: .infinity) // Center it
            .multilineTextAlignment(.center)
            .padding()
    }
}

struct EmptyListView_Previews: PreviewProvider {
    static var previews: some View {
        EmptyListView()
// <-----CHANGE START------>
            .background(Color.black)
// <-----CHANGE END-------->
    }
}
// MARK: END ADDED FILE - Views/ImageList/EmptyListView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/EmptyListView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/FullScreenImageView.swift ---
// File: BrickAI/Views/ImageList/FullScreenImageView.swift
// Updated to include download button functionality from ImageDetailView
// Now accepts ImageData instead of just Image
// Added drag-down-to-dismiss gesture
// Removed explicit 'X' close button

import SwiftUI

struct FullScreenImageView: View {
    // Input: ImageData object
// <-----CHANGE START------>
    let imageDataForDetails: ImageData // Renamed from imageData
    let actualUrlToDisplay: URL        // The specific URL to show
// <-----CHANGE END-------->

    // Environment variable for dismissing
    @Environment(\.dismiss) var dismiss
    
    // Manager Dependencies (for image loading & saving)
    @EnvironmentObject var imageDataManager: ImageDataManager
    @StateObject private var photoLibraryManager = PhotoLibraryManager()
    
    // State for Save Button
    @State private var isSaving = false
    @State private var showSaveAlert = false
    @State private var saveAlertTitle = ""
    @State private var saveAlertMessage = ""

    // State for Drag Gesture
    @State private var dragOffset: CGSize = .zero

// <-----CHANGE START------>
    // Initializer
    init(imageDataForDetails: ImageData, actualUrlToDisplay: URL) {
        self.imageDataForDetails = imageDataForDetails
        self.actualUrlToDisplay = actualUrlToDisplay
    }
// <-----CHANGE END-------->

    var body: some View {
        // Determine the URL and check cache
// <-----CHANGE START------>
        let imageUrl = actualUrlToDisplay // Use the specific URL passed in
// <-----CHANGE END-------->
        let cachedImage = imageDataManager.getImage(for: imageUrl)

        ZStack {
            // Background color - Opacity changes during drag
            Color.black
                .opacity(calculateBackgroundOpacity())
                .edgesIgnoringSafeArea(.all)
                .onTapGesture { // Tap background to dismiss
                     if dragOffset != .zero {
                         withAnimation(.interactiveSpring()) { dragOffset = .zero }
                     } else {
                          dismiss()
                     }
                }

            // --- Main Content Group (Image Display) ---
            Group {
                 if let loadedImage = cachedImage {
                     Image(uiImage: loadedImage)
                         .resizable()
                         .scaledToFit()
                 } else { // Removed "if let url = imageUrl" because imageUrl (actualUrlToDisplay) is non-optional
                     AsyncImage(url: imageUrl) { phase in // Use imageUrl directly
                         switch phase {
                         case .empty: ProgressView().tint(.white)
                         case .success(let loadedImage): loadedImage.resizable().scaledToFit()
                         case .failure: Image(systemName: "photo.fill").foregroundColor(.secondary)
                         @unknown default: EmptyView()
                         }
                     }
                     .onAppear { imageDataManager.ensureImageIsCached(for: imageUrl) } // Use imageUrl directly
                 }
                 // Removed "else" block for "photo.fill" as imageUrl is non-optional
            }
            .offset(y: dragOffset.height) // Apply vertical offset based on drag
            .gesture(dragGesture) // Attach drag gesture to image content
            
            // --- Overlays for Buttons ---
            // Bottom Right: Download Button (Remains)
            VStack {
                 Spacer()
                 HStack {
                     Spacer()
                     if isSaving {
                         ProgressView().tint(.white)
                             .frame(width: 44, height: 44)
                             .padding()
                             .background(Color.black.opacity(0.5))
                             .clipShape(Circle())
                     } else {
                         Button { initiateSaveProcess() } label: {
                             Image(systemName: "arrow.down.circle.fill")
                                  .font(.largeTitle)
                                  .foregroundColor(.white)
                         }
                         .frame(width: 44, height: 44)
                         .padding()
                         .background(Color.black.opacity(0.5))
                         .clipShape(Circle())
                         // .disabled(imageUrl == nil) // imageUrl (actualUrlToDisplay) is non-optional
                     }
                 }
            }
            .padding([.bottom, .trailing])

        } // End ZStack
        .alert(isPresented: $showSaveAlert) { // Alert remains the same
            Alert(title: Text(saveAlertTitle), message: Text(saveAlertMessage), dismissButton: .default(Text("OK")))
        }
        .environmentObject(imageDataManager)
        .animation(.interactiveSpring(), value: dragOffset)

    } // End body

    // Drag Gesture Definition (Unchanged)
    var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                if value.translation.height >= 0 {
                    self.dragOffset = value.translation
                }
            }
            .onEnded { value in
                let dragThreshold: CGFloat = 100
                // let velocityThreshold: CGFloat = 300 // Not used in this logic
                
                if value.translation.height > dragThreshold || value.predictedEndTranslation.height > dragThreshold * 1.5 {
                    print("Drag ended: Dismissing view.")
                    dismiss()
                } else {
                    print("Drag ended: Snapping back.")
                    self.dragOffset = .zero
                }
            }
    }

    // Helper for Background Opacity (Unchanged)
    func calculateBackgroundOpacity() -> Double {
        let maxDragDistance: CGFloat = UIScreen.main.bounds.height * 0.7
        let dragProgress = max(0, min(1, dragOffset.height / maxDragDistance))
        return 1.0 - Double(dragProgress * 0.7)
    }

    // --- Helper Functions for Saving (Unchanged) ---
    private func initiateSaveProcess() {
// <-----CHANGE START------>
        let urlToSave = self.actualUrlToDisplay // Use the specific URL that is being displayed
// <-----CHANGE END-------->
        isSaving = true
        if let cachedUIImage = imageDataManager.getImage(for: urlToSave) {
             print("FullScreenImageView: Saving cached image.")
             photoLibraryManager.saveImage(cachedUIImage) { result in handleSaveCompletion(result: result) }
        } else {
             print("FullScreenImageView: Image not cached. Requesting download and save.")
             photoLibraryManager.downloadAndSaveImage(url: urlToSave, imageDataManager: imageDataManager) { result in handleSaveCompletion(result: result) }
        }
    }

    private func handleSaveCompletion(result: Result<Void, Error>) {
         DispatchQueue.main.async {
              isSaving = false
              switch result {
              case .success: presentSaveAlert(success: true, message: "Image saved to Photos.")
              case .failure(let error): presentSaveAlert(success: false, message: error.localizedDescription)
              }
         }
    }

    private func presentSaveAlert(success: Bool, message: String) {
         saveAlertTitle = success ? "Success" : "Error"
         saveAlertMessage = message
         showSaveAlert = true
    }
    
} // End struct

// --- Preview (Unchanged) ---
struct FullScreenImageView_Previews: PreviewProvider {
    static var previews: some View {
        let sampleImageData = ImageData.previewData[0]
        let mockDataManager = ImageDataManager()

// <-----CHANGE START------>
        // Ensure a valid URL from sampleImageData is used for actualUrlToDisplay
        let displayUrl = sampleImageData.processedImageUrl ?? sampleImageData.originalImageUrl!

        FullScreenImageView(imageDataForDetails: sampleImageData, actualUrlToDisplay: displayUrl)
            .environmentObject(mockDataManager)
// <-----CHANGE END-------->
    }
}
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/FullScreenImageView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListCardView.swift ---
// MARK: MODIFIED FILE - Views/ImageList/ImageListCardView.swift
// Displays a card where the image takes up most of the card's height (approx 80% of screen height).
// Image fills its allocated space, cropping if necessary.
// Includes a horizontal paging scroll view for original/processed versions.
// Subtle status, date, and save button are overlaid or placed below the image.
// Improved caching logic in ImageItemView.

import SwiftUI

struct FullScreenInfo: Identifiable {
    let id = UUID()
    let imageDataForDetails: ImageData // To retain access to all data like status, prompt, etc.
    let urlToDisplay: URL             // The specific URL that was tapped
}

struct ImageListCardView: View {
    let image: ImageData
    let cardHeight: CGFloat

    @EnvironmentObject var imageDataManager: ImageDataManager
    @StateObject private var photoLibraryManager = PhotoLibraryManager()

    @State private var visibleImageUrl: URL?
    @State private var isSaving = false
    @State private var showSaveAlert = false
    @State private var saveAlertTitle = ""
    @State private var saveAlertMessage = ""
    @State private var activeFullScreenInfo: FullScreenInfo?

    private var controlsAreaHeight: CGFloat { cardHeight * 0.15 < 60 ? 60 : cardHeight * 0.15 }
    private var imageDisplayAreaHeight: CGFloat { cardHeight - controlsAreaHeight }

    var canShowBothImages: Bool {
        image.originalImageUrl != nil && image.processedImageUrl != nil
    }

    var initialOrOnlyImageUrl: URL? {
        image.processedImageUrl ?? image.originalImageUrl
    }

    private func statusColor(status: String) -> Color {
        switch status.uppercased() {
        case "UPLOADED", "PROCESSING": return .orange.opacity(0.9)
        case "COMPLETED": return .green.opacity(0.9)
        case "FAILED": return .red.opacity(0.9)
        default: return .secondary.opacity(0.8)
        }
    }

    var body: some View {
        VStack(spacing: 0) {
            GeometryReader { imageGeo in
                Group {
                    if canShowBothImages {
                        ScrollViewReader { proxy in
                            ScrollView(.horizontal) {
                                LazyHStack(spacing: 0) {
                                    // Display Processed Image First
                                    if let processedUrl = image.processedImageUrl {
                                        ImageItemView(url: processedUrl, parentSize: imageGeo.size, targetHeight: imageDisplayAreaHeight)
                                            .id(processedUrl)
                                            .onTapGesture {
                                                self.activeFullScreenInfo = FullScreenInfo(imageDataForDetails: image, urlToDisplay: processedUrl)
                                            }
                                    }
                                    // Then Original Image
                                    if let originalUrl = image.originalImageUrl {
                                        ImageItemView(url: originalUrl, parentSize: imageGeo.size, targetHeight: imageDisplayAreaHeight)
                                            .id(originalUrl)
                                            .onTapGesture {
                                                self.activeFullScreenInfo = FullScreenInfo(imageDataForDetails: image, urlToDisplay: originalUrl)
                                            }
                                    }
                                }
                                .scrollTargetLayout()
                            }
                            .scrollIndicators(.hidden)
                            .scrollTargetBehavior(.paging)
                            .scrollPosition(id: $visibleImageUrl)
                            .onAppear {
                                let targetUrl = image.processedImageUrl ?? image.originalImageUrl
                                visibleImageUrl = targetUrl
                                if let targetUrl { proxy.scrollTo(targetUrl, anchor: .center) }
                            }
                        }
                    } else {
                        ImageItemView(url: initialOrOnlyImageUrl, parentSize: imageGeo.size, targetHeight: imageDisplayAreaHeight)
                            .onTapGesture {
                                if let url = initialOrOnlyImageUrl {
                                     self.activeFullScreenInfo = FullScreenInfo(imageDataForDetails: image, urlToDisplay: url)
                                }
                            }
                            .onAppear { visibleImageUrl = initialOrOnlyImageUrl }
                    }
                }
            }
            .frame(height: imageDisplayAreaHeight)
            .clipped()

            VStack(spacing: 4) {
                if canShowBothImages {
                     HStack(spacing: 6) {
                          // Dot for Processed Image First
                          if let url = image.processedImageUrl {
                              Circle().fill(visibleImageUrl == url ? Color.primary.opacity(0.7) : Color.secondary.opacity(0.5)).frame(width: 7, height: 7)
                          }
                          // Then Dot for Original Image
                          if let url = image.originalImageUrl {
                              Circle().fill(visibleImageUrl == url ? Color.primary.opacity(0.7) : Color.secondary.opacity(0.5)).frame(width: 7, height: 7)
                          }
                     }
                     .frame(maxWidth: .infinity)
                     .padding(.top, 8)
                }

                HStack(alignment: .center) {
                    VStack(alignment: .leading, spacing: 2) {
                        Text(image.status.capitalized)
                            .font(.caption).fontWeight(.medium)
                            .foregroundColor(statusColor(status: image.status))
                        Text(image.createdAt.formatted(date: .abbreviated, time: .omitted))
                            .font(.caption2).foregroundColor(.secondary) // Secondary color should contrast well on systemGray5
                    }
                    Spacer()
                    if isSaving {
                        ProgressView().frame(width: 30, height: 30)
                    } else {
                        Button { initiateSaveProcess() } label: {
                            Image(systemName: "arrow.down.circle")
                                .font(.title3).foregroundColor(.blue.opacity(0.9))
                        }
                        .frame(width: 30, height: 30)
                        .disabled(visibleImageUrl == nil)
                    }
                }
                .padding(.horizontal, 12)
                .padding(.bottom, 8)
                .padding(.top, canShowBothImages ? 0 : 8)
            }
            .frame(height: controlsAreaHeight)
            .frame(maxWidth: .infinity)
        }
        .frame(height: cardHeight)
// <-----CHANGE START------>
        .background(Color(UIColor.systemGray5)) // New card background
// <-----CHANGE END-------->
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.12), radius: 5, x: 0, y: 2)
        .clipped()
        .alert(isPresented: $showSaveAlert) {
            Alert(title: Text(saveAlertTitle), message: Text(saveAlertMessage), dismissButton: .default(Text("OK")))
        }
        .fullScreenCover(item: $activeFullScreenInfo) { infoItem in
            FullScreenImageView(imageDataForDetails: infoItem.imageDataForDetails, actualUrlToDisplay: infoItem.urlToDisplay)
               .environmentObject(imageDataManager)
        }
    }

    private func initiateSaveProcess() {
        guard let urlToSave = visibleImageUrl else {
            presentSaveAlert(success: false, message: "No image selected to save.")
            return
        }
        isSaving = true
        if let cachedUIImage = imageDataManager.getImage(for: urlToSave) {
            photoLibraryManager.saveImage(cachedUIImage) { result in handleSaveCompletion(result: result) }
        } else {
            photoLibraryManager.downloadAndSaveImage(url: urlToSave, imageDataManager: imageDataManager) { result in handleSaveCompletion(result: result) }
        }
    }

    private func handleSaveCompletion(result: Result<Void, Error>) {
         DispatchQueue.main.async {
              isSaving = false
              switch result {
              case .success: presentSaveAlert(success: true, message: "Image saved to Photos.")
              case .failure(let error): presentSaveAlert(success: false, message: error.localizedDescription)
              }
         }
    }

    private func presentSaveAlert(success: Bool, message: String) {
         saveAlertTitle = success ? "Success" : "Error"
         saveAlertMessage = message
         showSaveAlert = true
    }
}

// Helper view to render each image within the horizontal scroller
struct ImageItemView: View {
    let url: URL?
    let parentSize: CGSize
    let targetHeight: CGFloat

    @EnvironmentObject var imageDataManager: ImageDataManager
    @State private var locallyCachedUIImage: UIImage? = nil
    @State private var isLoadingCoreDataCache: Bool = true // Initially true to check Core Data

    var body: some View {
        Group {
            if isLoadingCoreDataCache {
                // Placeholder while checking our Core Data cache
                ZStack {
                    Color(.systemGray5) // Consistent placeholder background
                    ProgressView()
                }
            } else if let uiImage = locallyCachedUIImage {
                // Image successfully loaded from Core Data cache
                Image(uiImage: uiImage)
                    .resizable()
                    .aspectRatio(contentMode: .fill) // Fill the frame, crop if necessary
            } else if let imageURL = url {
                // Not in Core Data, fall back to SwiftUI.AsyncImage
                // AsyncImage handles its own network fetching and URLCache
                AsyncImage(url: imageURL) { phase in
                    if let image = phase.image {
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            // Optional: If AsyncImage loads successfully, we could try to update
                            // our Core Data cache here too, if not already handled by ensureImageIsCached.
                            // For simplicity, ensureImageIsCached in .task handles this.
                    } else if phase.error != nil {
                        ZStack {
                            Color(.systemGray4)
                            Image(systemName: "photo.fill.on.rectangle.fill")
                                .resizable().scaledToFit().foregroundColor(.secondary).padding()
                        }
                    } else { // Loading phase of AsyncImage
                        ZStack {
                            Color(.systemGray5)
                            ProgressView()
                        }
                    }
                }
            } else { // URL is nil
                ZStack {
                    Color(.systemGray4)
                    Image(systemName: "photo.fill")
                        .resizable().scaledToFit().foregroundColor(.secondary).padding()
                }
            }
        }
        .frame(width: parentSize.width, height: targetHeight)
        .clipped()
        .task { // Replaced .onAppear with .task for async work
            guard isLoadingCoreDataCache, let imageURL = url else {
                // If not loading cache anymore, or URL is nil, no need to proceed
                if url == nil { isLoadingCoreDataCache = false }
                return
            }

            // Attempt to load from ImageDataManager's Core Data cache
            // This is a synchronous call on MainActor within ImageDataManager
            let cachedImage = imageDataManager.getImage(for: imageURL)

            if let img = cachedImage {
                self.locallyCachedUIImage = img
            } else {
                // Not found in Core Data.
                // Trigger ImageDataManager to download and store it in Core Data for future use.
                // This happens in the background and doesn't block SwiftUI.AsyncImage.
                imageDataManager.ensureImageIsCached(for: imageURL)
            }
            self.isLoadingCoreDataCache = false // Finished checking/triggering Core Data cache
        }
    }
}

// MARK: END MODIFIED FILE - Views/ImageList/ImageListCardView.swift

--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListCardView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListView.swift ---
// MARK: MODIFIED FILE - Views/ImageListView2.swift
// Displays images in a continuous vertical scroll. Each acknowledged image card
// takes up approximately 80% of the screen height.

import SwiftUI

struct ImageListView: View {
    @EnvironmentObject var imageDataManager: ImageDataManager
    @EnvironmentObject var userManager: UserManager
    @State private var showErrorAlert = false

    var body: some View {
        NavigationView { // Or NavigationStack
            Group {
                if imageDataManager.isLoadingList && imageDataManager.images.isEmpty && imageDataManager.pendingUploads.isEmpty {
                    LoadingView()
                } else if imageDataManager.images.isEmpty && imageDataManager.pendingUploads.isEmpty && imageDataManager.listError == nil && !imageDataManager.isLoadingList {
                    EmptyListView()
                } else {
                    ImageListContentView2()
                }
            }
            .background(Color.black.ignoresSafeArea())
            .onChange(of: imageDataManager.listError) { _, newError in
                showErrorAlert = (newError != nil)
            }
            .alert("Error Loading Images", isPresented: $showErrorAlert, presenting: imageDataManager.listError) { error in
                Button("Retry") { imageDataManager.prepareImageData() }
                if case .sessionExpired = error { Button("Log Out", role: .destructive) { userManager.clearUser() } }
                else if case .authenticationTokenMissing = error { Button("Log Out", role: .destructive) { userManager.clearUser() } }
                else { Button("OK", role: .cancel) { } }
            } message: { error in Text(error.localizedDescription) }
        }
        .environmentObject(imageDataManager)
        .environmentObject(userManager)
    }
}

struct ImageListContentView2: View {
    @EnvironmentObject var imageDataManager: ImageDataManager

    var body: some View {
        GeometryReader { geometry in
            ScrollView(.vertical) {
                LazyVStack(spacing: 20) { // Spacing between cards
                    // Section for Pending Uploads (smaller cards)
                    if !imageDataManager.pendingUploads.isEmpty {
                        Section {
                            ForEach(imageDataManager.pendingUploads) { pendingItem in
                                PendingImageCardView(pendingUpload: pendingItem)
                                    .padding(.horizontal)
                            }
                        } header: {
                            Text("Currently Uploading")
                                .font(.headline)
// <-----CHANGE START------>
                                .foregroundColor(Color(UIColor.systemGray)) // Adjusted for black background
// <-----CHANGE END-------->
                                .padding(.top)
                                .padding(.horizontal)
                        }
                        .padding(.bottom, 10)
                    }

                    // Acknowledged Images (large cards, 80% screen height)
                    if !imageDataManager.images.isEmpty {
                        let cardHeight = geometry.size.height * 0.8 // Calculate 80% of screen height

                        ForEach(imageDataManager.images) { image in
                            AcknowledgedImageCardView(image: image, cardHeight: cardHeight)
                                .padding(.horizontal) // Horizontal padding for the card in the list
                        }
                    }
                }
                .padding(.vertical) // Padding at the top and bottom of the LazyVStack
            }
            .refreshable {
                print("ImageListContentView2: Refresh triggered.")
                imageDataManager.prepareImageData()
            }
        }
        .navigationTitle("Creations")
        .navigationBarTitleDisplayMode(.inline)
// <-----CHANGE START------>
        .preferredColorScheme(.dark) // Ensures nav bar items are light on a dark bar
// <-----CHANGE END-------->
        .toolbar {
            ToolbarItem(placement: .principal) {
                VStack {
                    Text("Creations").font(.headline) // Color will be handled by preferredColorScheme
                    let totalCount = imageDataManager.images.count + imageDataManager.pendingUploads.count
                    if totalCount > 0 {
                        Text("(\(totalCount) total)")
                            .font(.caption)
                            .foregroundColor(.secondary) // Secondary color on dark bar should be light gray
                    }
                }
            }
        }
    }
}

struct AcknowledgedImageCardView: View {
    let image: ImageData
    let cardHeight: CGFloat

    var body: some View {
        ImageListCardView(image: image, cardHeight: cardHeight)
    }
}

struct PendingImageCardView: View {
    let pendingUpload: PendingUploadInfo
    var body: some View {
        VStack(alignment: .leading) {
            HStack(spacing: 15) {
                Image(systemName: pendingUpload.placeholderImageName)
                    .resizable().aspectRatio(contentMode: .fit).frame(width: 30, height: 30)
                    .foregroundColor(.secondary).padding(15).frame(width: 60, height: 60)
// <-----CHANGE START------>
                    .background(Color(UIColor.systemGray4)) // Differentiated icon background
// <-----CHANGE END-------->
                    .cornerRadius(8)
                VStack(alignment: .leading, spacing: 4) {
                    Text("Status: Uploading...").font(.headline).foregroundColor(.orange)
// <-----CHANGE START------>
                    Text("Added: \(pendingUpload.createdAt, style: .relative) ago").font(.caption).foregroundColor(Color(UIColor.systemGray)) // Adjusted for card background
// <-----CHANGE END-------->
                }
                Spacer()
                ProgressView().scaleEffect(0.9)
            }
        }
// <-----CHANGE START------>
        .padding().background(Color(UIColor.systemGray5)) // New card background
// <-----CHANGE END-------->
        .cornerRadius(12).shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2)
        .opacity(0.8)
    }
}

// MARK: END MODIFIED FILE - Views/ImageListView2.swift

--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/LoadingView.swift ---
// MARK: ADDED FILE - Views/ImageList/LoadingView.swift
// File: BrickAI/Views/ImageList/LoadingView.swift
// Simple view for the initial loading state

import SwiftUI

struct LoadingView: View {
    var body: some View {
// <-----CHANGE START------>
        ProgressView {
            Text("Loading Images...")
                .foregroundColor(.white)
        }
        .progressViewStyle(CircularProgressViewStyle(tint: .white))
// <-----CHANGE END-------->
            .frame(maxWidth: .infinity, maxHeight: .infinity) // Center it
    }
}

struct LoadingView_Previews: PreviewProvider {
    static var previews: some View {
        LoadingView()
// <-----CHANGE START------>
            .background(Color.black)
// <-----CHANGE END-------->
    }
}
// MARK: END ADDED FILE - Views/ImageList/LoadingView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/LoadingView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/LoginView.swift ---
// MARK: MODIFIED FILE - Views/LoginView.swift
// File: BrickAI/Views/LoginView.swift
// Added trigger for ImageDataManager

import SwiftUI
import AuthenticationServices

struct LoginView: View {
    @EnvironmentObject var userManager: UserManager
    // MARK: <<< ADDED START >>>
    // Inject ImageDataManager from environment
    @EnvironmentObject var imageDataManager: ImageDataManager
    // MARK: <<< ADDED END >>>

    @State private var loginError: String? = nil
    @State private var isAuthenticating: Bool = false

    var body: some View {
        VStack {
            if userManager.isLoggedIn {
                 HomeView()
                     .transition(.opacity.combined(with: .scale))
                     // Pass environment objects down if needed by HomeView or its children
                     // Note: HomeView itself might not need them directly, but its destinations (Settings, ImageList) will
                     .environmentObject(userManager)
                     .environmentObject(imageDataManager) // Pass down imageDataManager
            } else {
                 // --- Login UI (No changes within this part) ---
                 Spacer()
                 Text("Welcome to BrickAI").font(.largeTitle).padding(.bottom, 40)
                 if let errorMsg = loginError { Text(errorMsg).foregroundColor(.red).padding(.horizontal).multilineTextAlignment(.center).transition(.opacity).padding(.bottom) }
                 if isAuthenticating { ProgressView("Authenticating...").padding().transition(.opacity)
                 } else {
                     SignInWithAppleButton(.signIn, onRequest: { request in request.requestedScopes = [.fullName, .email] }, onCompletion: { result in
                         isAuthenticating = true; loginError = nil
                         switch result {
                         case .success(let authResults):
                             // ... (existing credential handling logic) ...
                             guard let appleIDCredential = authResults.credential as? ASAuthorizationAppleIDCredential else { handleLoginError("Failed to process Apple credentials."); return }
                             let appleUserID = appleIDCredential.user
                             var currentUserName: String? = nil
                             if let fullName = appleIDCredential.fullName, let given = fullName.givenName, let family = fullName.familyName { let name = "\(given) \(family)".trimmingCharacters(in: .whitespacesAndNewlines); if !name.isEmpty { currentUserName = name } }
                             if currentUserName == nil { currentUserName = KeychainService.loadString(forKey: kKeychainAccountUserName) ?? "User \(appleUserID.prefix(4))" }
                             guard let authCodeData = appleIDCredential.authorizationCode, let authCode = String(data: authCodeData, encoding: .utf8) else { handleLoginError("Could not retrieve authorization code from Apple."); return }

                             NetworkManager.exchangeAuthCode(authorizationCode: authCode) { exchangeResult in
                                 switch exchangeResult {
                                 case .success(let sessionToken):
                                     // Save credentials (UserManager updates isLoggedIn internally)
                                     userManager.saveCredentials(userName: currentUserName, userIdentifier: appleUserID, sessionToken: sessionToken)
                                     // Login state is updated by userManager, onChange below will trigger image fetch
                                     isAuthenticating = false
                                 case .failure(let error):
                                     handleLoginError(error.localizedDescription)
                                 }
                             }
                         case .failure(let error):
                             if (error as? ASAuthorizationError)?.code == .canceled { isAuthenticating = false; loginError = nil }
                             else { handleLoginError("Sign in with Apple failed: \(error.localizedDescription)") }
                         }
                     })
                     .signInWithAppleButtonStyle(.black).frame(width: 280, height: 45).padding().disabled(isAuthenticating).transition(.opacity.combined(with: .scale(scale: 0.9)))
                 }
                 Spacer()
                 // --- End Login UI ---
            }
        }
        .animation(.default, value: userManager.isLoggedIn)
        .animation(.easeInOut, value: loginError)
        .animation(.easeInOut, value: isAuthenticating)
        // MARK: <<< ADDED START >>>
        // Trigger image data preparation when login state changes or on initial appearance if already logged in
        .onChange(of: userManager.isLoggedIn) { _, newValue in
            if newValue {
                print("LoginView: User logged in (onChange). Preparing image data.")
                imageDataManager.prepareImageData()
            }
            // No action needed if newValue is false (logout handled elsewhere)
        }
        .onAppear {
             // Check if already logged in when the view appears
             if userManager.isLoggedIn {
                  print("LoginView: Already logged in (onAppear). Preparing image data.")
                  imageDataManager.prepareImageData()
             }
        }
        // MARK: <<< ADDED END >>>
    }

    private func handleLoginError(_ message: String) {
         DispatchQueue.main.async {
              self.loginError = message
              self.isAuthenticating = false
         }
    }
}

// Previews (kept as requested)
struct LoginView_Previews: PreviewProvider {
    static var previews: some View {
        // Create mock managers for preview if needed
        let mockUserManager = UserManager.shared // Use singleton or create specific mock
        let mockImageDataManager = ImageDataManager() // Use initializer or create specific mock

        LoginView()
            .environmentObject(mockUserManager)
            .environmentObject(mockImageDataManager)
    }
}
// MARK: END MODIFIED FILE - Views/LoginView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/LoginView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/PaymentsView.swift ---
// MARK: MODIFIED FILE - Views/PaymentsView.swift
// File: BrickAI/Views/PaymentsView.swift
// Updated to integrate with StoreManager for In-App Purchases.

import SwiftUI
import StoreKit // Import StoreKit

struct PaymentsView: View {
    // EnvironmentObject to access the shared StoreManager instance
    @EnvironmentObject var storeManager: StoreManager
    @Environment(\.dismiss) var dismiss

    // State for managing alerts
    @State private var showAlert = false
    @State private var alertTitle = ""
    @State private var alertMessage = ""

    // New struct for product display details
    struct ProductDisplayDetails {
        let tries: Int
        let imageName: String // Still here, but not used in the view
        let isPopular: Bool // To mark the "Most Popular" option
    }

    // Map product IDs to their display details
    private let productDetailsMap: [String: ProductDisplayDetails] = [
        "com.NEXTAppDevelopment.brickai.1dollar": ProductDisplayDetails(tries: 5, imageName: "brickai_1_dollar", isPopular: false),
        "com.NEXTAppDevelopment.brickai.5dollars": ProductDisplayDetails(tries: 30, imageName: "brickai_5_dollars", isPopular: true),
        "com.NEXTAppDevelopment.brickai.20dollars": ProductDisplayDetails(tries: 100, imageName: "brickai_20_dollars", isPopular: false)
    ]

    var body: some View {
        VStack(spacing: 20) {
            Text("Sale")
                .font(.largeTitle)
                .fontWeight(.bold)
                .padding(.top, 30)
                .foregroundColor(.black) // Title should be black

            if storeManager.isLoadingProducts {
                ProgressView("Loading Products...")
                    .padding()
            } else {
                // Iterate over sorted products that are in our productDetailsMap
                let displayableProducts = storeManager.products.filter { productDetailsMap.keys.contains($0.productIdentifier) }

                if !displayableProducts.isEmpty {
// <-----CHANGE START------>
                    // Use a ScrollView to ensure content is scrollable if it exceeds screen height
                    ScrollView {
                        VStack(spacing: 15) { // Reduced spacing between cards
                            ForEach(displayableProducts.sorted(by: { (p1, p2) -> Bool in
                                // Custom sorting: popular first, then by price
                                guard let details1 = productDetailsMap[p1.productIdentifier],
                                      let details2 = productDetailsMap[p2.productIdentifier] else {
                                    return false // Should not happen if products are filtered
                                }
                                if details1.isPopular && !details2.isPopular {
                                    return true
                                } else if !details1.isPopular && details2.isPopular {
                                    return false
                                }
                                return p1.price.decimalValue < p2.price.decimalValue
                            }), id: \.productIdentifier) { product in
                                productPurchaseView(product: product)
                            }
                        }
                        .padding(.horizontal) // Horizontal padding for the VStack of cards
                        .padding(.top, 20) // Padding above the first card
                        .padding(.bottom, 20) // Padding below the last card
                    }
// <-----CHANGE END-------->
                } else {
                    // No products found or not loaded yet
                    Text("No products available at the moment. Please try again later.")
                        .foregroundColor(.gray) // Adjusted for white background
                        .multilineTextAlignment(.center)
                        .padding()
                    Button("Refresh Products") {
                        storeManager.fetchProducts()
                    }
                    .padding()
                    .tint(.blue) // Explicitly set tint if needed
                }
            }

            Spacer() // Pushes content to the top

            // Display transaction status (optional, for debugging or more detailed UI)
            if let state = storeManager.transactionState {
                Text("Transaction Status: \(transactionStatusString(state))")
                    .font(.caption)
                    .foregroundColor(.gray) // Adjusted for white background
                    .padding(.bottom)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.white.ignoresSafeArea()) // White background for the whole view
        .navigationTitle("Purchase Credits") // This title will be used if embedded in NavigationView
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            // Fetch products when the view appears if they haven't been loaded yet
            if storeManager.products.isEmpty {
                storeManager.fetchProducts()
            }
        }
        .alert(isPresented: $showAlert) {
            Alert(
                title: Text(alertTitle),
                message: Text(alertMessage),
                dismissButton: .default(Text("OK")) {
                    if alertTitle == "Purchase Successful" {
                        dismiss()
                    }
                }
            )
        }
    }

    /// Creates a view for a single product, allowing purchase.
    @ViewBuilder
    private func productPurchaseView(product: SKProduct) -> some View {
// <-----CHANGE START------>
        // Ensure productDetails exist for the given product
        if let details = productDetailsMap[product.productIdentifier] {
            ZStack(alignment: .topLeading) { // Use ZStack for the "Most Popular" badge overlay
                // Main card content
                VStack(spacing: 0) { // Set spacing to 0, control with padding
                    HStack {
                        VStack(alignment: .leading, spacing: 2) { // Reduced spacing
                            Text("\(details.tries)")
                                .font(.system(size: 36, weight: .bold)) // Larger credit count
                                .foregroundColor(.black)
                            Text("Credits")
                                .font(.footnote) // Smaller "Credits" text
                                .foregroundColor(.gray)
                        }
                        Spacer()
                        Text(product.localizedPrice ?? "Price")
                            .font(.title2) // Slightly larger price
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                    }
                    .padding(.horizontal, 20)
                    .padding(.top, 20) // Padding for top content
                    .padding(.bottom, 15) // Spacing below text content

                    Button(action: {
                        // Initiate purchase
                        storeManager.buyProduct(product) { result in
                            handlePurchaseCompletion(result: result, product: product)
                        }
                    }) {
                        // Dynamic button label based on purchase state
                        if storeManager.transactionState == .purchasing &&
                           storeManager.products.first(where: { $0.productIdentifier == product.productIdentifier }) != nil &&
                           SKPaymentQueue.default().transactions.first(where: {$0.payment.productIdentifier == product.productIdentifier && $0.transactionState == .purchasing }) != nil {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .frame(maxWidth: .infinity)
                                .frame(height: 44) // Fixed height for the button area
                        } else {
                            Text("Buy Now")
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .frame(height: 44) // Fixed height for the button
                        }
                    }
                    .background(Color.blue)
                    .cornerRadius(8) // Slightly less rounded corners for button
                    .padding(.horizontal, 20)
                    .padding(.bottom, 20) // Padding for button at bottom
                    .disabled(storeManager.transactionState == .purchasing)
                }
                .background(Color(UIColor.systemGray6)) // Use a very light gray for card background
                .cornerRadius(12) // Card corner radius
                // .shadow(color: .gray.opacity(0.25), radius: 5, x: 0, y: 3) // Subtle shadow

                // "Most Popular" Badge
                if details.isPopular {
                    Text("Most Popular")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(.white)
                        .padding(.horizontal, 10)
                        .padding(.vertical, 5)
                        .background(Color.orange) // Changed badge color
                        .clipShape(Capsule())
                        .offset(x: -8, y: -12) // Position badge at top-left, slightly offset
                }
            }
            .padding(.bottom, 5) // Small space below each card before the next one
        } else {
            // Fallback if productDetails are somehow not found (should be rare)
            Text("Product information for \(product.productIdentifier) is not available.")
                .padding()
                .foregroundColor(.red)
        }
// <-----CHANGE END-------->
    }

    /// Handles the completion of a purchase attempt.
    private func handlePurchaseCompletion(result: Result<SKPaymentTransaction, Error>, product: SKProduct) {
        DispatchQueue.main.async {
            switch result {
            case .success(let transaction):
                // Purchase was successful
                print("PaymentsView: Purchase successful for \(product.localizedTitle)!")
                self.alertTitle = "Purchase Successful"
                self.alertMessage = "You've successfully purchased \(product.localizedTitle)."
                self.showAlert = true

            case .failure(let error):
                // Purchase failed
                print("PaymentsView: Purchase failed for \(product.localizedTitle). Error: \(error.localizedDescription)")
                if let skError = error as? SKError, skError.code == .paymentCancelled {
                    // User cancelled, no alert needed or a subtle one
                    self.alertTitle = "Purchase Cancelled"
                    self.alertMessage = "Your purchase of \(product.localizedTitle) was cancelled."
                    // Optionally show alert: self.showAlert = true
                } else {
                    self.alertTitle = "Purchase Failed"
                    self.alertMessage = "Could not complete your purchase of \(product.localizedTitle). \(error.localizedDescription)"
                    self.showAlert = true
                }
            }
        }
    }

    /// Helper to convert transaction state to a readable string
    private func transactionStatusString(_ state: SKPaymentTransactionState) -> String {
        switch state {
        case .purchasing: return "Purchasing..."
        case .purchased: return "Purchased"
        case .failed: return "Failed"
        case .restored: return "Restored"
        case .deferred: return "Deferred (Awaiting Approval)"
        @unknown default: return "Unknown"
        }
    }
}

--- File End: ios-app/BrickAI/BrickAI/Views/PaymentsView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/UploadSuccessPopupView.swift ---
// MARK: NEW FILE - Views/Notifications/UploadSuccessPopupView.swift
// File: BrickAI/Views/Notifications/UploadSuccessPopupView.swift
// An enhanced popup view to indicate successful image upload.

import SwiftUI

struct UploadSuccessPopupView: View {
    // State for entry animation
    @State private var scaleEffect: CGFloat = 0.5
    @State private var opacity: Double = 0.0

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: "checkmark.circle.fill")
                .font(.title) // Slightly larger icon
                .foregroundColor(.white)
            Text("Image Uploaded!") // More exciting text
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(.white)
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 20)
        // Use a vibrant green gradient background
        .background(
            LinearGradient(
                gradient: Gradient(colors: [Color.green.opacity(0.9), Color.green.opacity(0.7)]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .clipShape(Capsule()) // Use Capsule shape
        .shadow(color: .black.opacity(0.3), radius: 8, x: 0, y: 4) // Enhanced shadow
        // Apply scaling and opacity based on state for entry animation
        .scaleEffect(scaleEffect)
        .opacity(opacity)
        // Animation triggered on appear
        .onAppear {
            withAnimation(.spring(response: 0.4, dampingFraction: 0.6, blendDuration: 0)) {
                scaleEffect = 1.0 // Scale up
                opacity = 1.0   // Fade in
            }
        }
    }
}

// Preview for UploadSuccessPopupView
struct UploadSuccessPopupView_Previews: PreviewProvider {
    static var previews: some View {
        UploadSuccessPopupView()
            .padding()
            .previewLayout(.sizeThatFits)
            .background(Color.gray) // Add background for contrast
    }
}
// MARK: END NEW FILE - Views/Notifications/UploadSuccessPopupView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/UploadSuccessPopupView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/UserInfoView.swift ---
// MARK: MODIFIED FILE - Views/UserInfoView.swift
// Updated to clear ImageDataManager cache on logout
// <-----CHANGE START------>
// Added call to stop ImageDataManager polling on logout
// <-----CHANGE END-------->


import SwiftUI

struct UserInfoView: View {
     @EnvironmentObject var userManager: UserManager
     // Inject ImageDataManager to clear cache and stop polling
     @EnvironmentObject var imageDataManager: ImageDataManager
     @State private var showingDeleteConfirmation = false // Added for delete confirmation

     var body: some View {
          Form {
              Section("Account") {
                   Text("Username: \(userManager.userName ?? "N/A")")
                   Text("User ID: \(userManager.userIdentifier ?? "N/A")")
                   Button("Log Out", role: .destructive) {
                        // <-----CHANGE START------>
                        // 1. Stop polling BEFORE clearing cache/user
                        print("UserInfoView: Logging out. Stopping image polling.")
                        imageDataManager.stopPolling()
                        // 2. Clear image cache
                        print("UserInfoView: Clearing image cache.")
                        imageDataManager.clearCache()
                        // 3. Then clear user session
                        print("UserInfoView: Clearing user credentials.")
                        userManager.clearUser()
                   }
                   // <-----CHANGE START------>
                   // Added Delete Account Button
                   Button("Delete Account", role: .destructive) {
                        showingDeleteConfirmation = true
                   }
                   // <-----CHANGE END-------->
              }
              // Add other settings sections...
          }
          .navigationTitle("User")
          // <-----CHANGE START------>
          // Added Alert for Delete Confirmation
          .alert("Delete Account?", isPresented: $showingDeleteConfirmation) {
              Button("Cancel", role: .cancel) { }
              Button("Yes, Delete", role: .destructive) {
                  print("UserInfoView: Delete confirmation received.")
                  // <-----CHANGE START------>
                  // Call UserManager to delete account
                  userManager.deleteCurrentUserAccount { result in
                      switch result {
                      case .success:
                          print("UserInfoView: Account deletion process successful. Performing local cleanup.")
                          // local data cleanup after successful account deletion
                          print("UserInfoView: Stopping image polling post-delete.")
                          imageDataManager.stopPolling()
                          print("UserInfoView: Clearing image cache post-delete.")
                          imageDataManager.clearCache()
                          // userManager.clearUser() is now called within deleteCurrentUserAccount
                          print("UserInfoView: User state should be cleared by UserManager.")
                      case .failure(let error):
                          // Handle error (e.g., show an alert to the user)
                          print("UserInfoView: Account deletion failed: \(error.localizedDescription)")
                          // Optionally, present an error alert to the user here
                      }
                  }
                  // <-----CHANGE END-------->
              }
          } message: {
              Text("Are you sure you want to permanently delete your account? This action cannot be undone.")
          }
          // <-----CHANGE END-------->
     }
}
// MARK: END MODIFIED FILE - Views/UserInfoView.swift

--- File End: ios-app/BrickAI/BrickAI/Views/UserInfoView.swift ---


