--- File Start: ios-app/BrickAI/BrickAI/BrickAIApp.swift ---
// MARK: MODIFIED FILE - BrickAIApp.swift
//
//  BrickAIApp.swift
//  BrickAI
//
//  Created by Max U on 4/5/25.
//

import SwiftUI

@main
struct BrickAIApp: App {
    // MARK: <<< MODIFIED START >>>
    // Instantiate UserManager and ImageDataManager as StateObjects at the top level
    @StateObject private var userManager = UserManager.shared // Keep as singleton access if preferred
    @StateObject private var imageDataManager = ImageDataManager()
    // MARK: <<< MODIFIED END >>>

    var body: some Scene {
        WindowGroup {
            // MARK: <<< MODIFIED START >>>
            // Pass both managers into the environment
            LoginView()
              .environmentObject(userManager)
              .environmentObject(imageDataManager) // Inject ImageDataManager
            // MARK: <<< MODIFIED END >>>
        }
    }
}
// MARK: END MODIFIED FILE - BrickAIApp.swift
--- File End: ios-app/BrickAI/BrickAI/BrickAIApp.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/CameraManager.swift ---
import Foundation
import AVFoundation
import UIKit // Needed for UIImage
import Combine // Needed for ObservableObject

class CameraManager: ObservableObject {
    static let shared = CameraManager()
    let session = AVCaptureSession()

    // --- Published Properties ---
    @Published var capturedImage: UIImage? // Holds the image after capture
    @Published private(set) var isPermissionGranted: Bool = false // Camera permission state

    // --- Private Properties ---
    private var videoDeviceInput: AVCaptureDeviceInput?
    private let photoOutput = AVCapturePhotoOutput()
    // Add a delegate object to handle photo capture callbacks
    private var photoCaptureDelegate: PhotoCaptureProcessor?

    // --- Initialization ---
    private init() {
        print("CameraManager: Initializing...")
        checkCameraPermission() // Check initial permission status
        // Configure only if permission is initially granted, or defer until granted?
        // Let's configure regardless, session won't work without permission anyway.
        configureSession()
    }

    // --- Permission Handling ---
    func checkCameraPermission() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized: // The user has previously granted access to the camera.
            print("CameraManager: Permission already granted.")
            self.isPermissionGranted = true
        case .notDetermined: // The user has not yet been asked for camera access.
            print("CameraManager: Permission not determined yet.")
            self.isPermissionGranted = false
            // Don't request here automatically, let UI trigger request if needed
        case .denied: // The user has previously denied access.
             print("CameraManager: Permission denied previously.")
            self.isPermissionGranted = false
        case .restricted: // The user can't grant access due to restrictions.
             print("CameraManager: Permission restricted.")
            self.isPermissionGranted = false
        @unknown default:
             print("CameraManager: Unknown permission status.")
            self.isPermissionGranted = false
        }
    }

    func requestCameraPermission() {
         // Request on background thread? Apple docs don't specify, but UI updates should be main.
         AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
             DispatchQueue.main.async { // Update state on main thread
                 self?.isPermissionGranted = granted
                 if granted {
                     print("CameraManager: Permission granted by user.")
                     // Optionally start session immediately if configured and needed?
                     // self?.startSession()
                 } else {
                     print("CameraManager: Permission denied by user.")
                 }
             }
         }
    }

    // --- Session Configuration ---
    func configureSession() {
        // Should only run if session isn't already configured? Add check?
        guard session.inputs.isEmpty && session.outputs.isEmpty else {
             print("CameraManager: Session already configured.")
             return
        }
        
        session.beginConfiguration()
        session.sessionPreset = .photo // Use high quality preset

        // Find video device (prefer back camera)
        guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {
            print("CameraManager Error: Failed to find back camera.")
            session.commitConfiguration()
            return
        }

        // Create video input
        do {
            videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)
        } catch {
            print("CameraManager Error: Could not create video device input: \(error)")
            session.commitConfiguration()
            return
        }

        // Add video input
        if let videoInput = videoDeviceInput, session.canAddInput(videoInput) {
            session.addInput(videoInput)
        } else {
            print("CameraManager Error: Could not add video device input to session.")
            session.commitConfiguration()
            return
        }

        // Add photo output
        if session.canAddOutput(photoOutput) {
            session.addOutput(photoOutput)
            photoOutput.isHighResolutionCaptureEnabled = true
            // Configure other settings like photo quality, stabilization if needed
        } else {
             print("CameraManager Error: Could not add photo output to session.")
            session.commitConfiguration()
            return
        }

        session.commitConfiguration()
        print("CameraManager: Session configured successfully.")
    }

    // --- Session Control ---
    // Start the session if permission is granted and it's not already running
    func startSession() {
        guard isPermissionGranted else {
            print("CameraManager: Cannot start session, permission not granted.")
            return
        }
        // Run on a background thread to avoid blocking UI
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            if !self.session.isRunning {
                self.session.startRunning()
                print("CameraManager: Session started running.")
            } else {
                 // print("CameraManager: Session already running.") // Less noisy log
            }
        }
    }

    // Stop the session if it's running
    func stopSession() {
        // Ensure stop is on background thread if start was
         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
               guard let self = self else { return }
               if self.session.isRunning {
                    self.session.stopRunning()
                    print("CameraManager: Session stopped running.")
               } else {
                   // print("CameraManager: Session already stopped.") // Less noisy log
               }
         }
    }

    // --- Photo Capture ---
    func capturePhoto() {
         guard session.isRunning else {
              print("CameraManager Error: Cannot capture photo, session is not running.")
              // Maybe try starting session? Or just return?
              return
         }
         guard isPermissionGranted else {
             print("CameraManager Error: Cannot capture photo, permission denied.")
             return
         }
        
         print("CameraManager: Initiating photo capture.")
         let settings = AVCapturePhotoSettings()
         // Configure settings (flash, quality, etc.) if needed
         // settings.flashMode = .auto // Example

         // Create a delegate object instance for this capture request
         // This delegate will handle receiving the photo data
         photoCaptureDelegate = PhotoCaptureProcessor { [weak self] image in
              // This completion block is called by the delegate when processing is done
              DispatchQueue.main.async { // Update published property on main thread
                  self?.capturedImage = image
                  print("CameraManager: Photo captured and processed. Updated published property.")
                  // Stop session after capture? Yes, typically done by HomeView's onChange.
                  // self?.stopSession()
              }
              // Release the delegate reference once capture is complete
               self?.photoCaptureDelegate = nil
         }
        
         // Initiate the capture
         photoOutput.capturePhoto(with: settings, delegate: photoCaptureDelegate!)
    }
    
    // --- State Reset ---
    // Call this from CapturedImageView (or HomeView) to dismiss the captured image view
    func resetCaptureState() {
        DispatchQueue.main.async { // Ensure UI updates on main thread
            self.capturedImage = nil
            print("CameraManager: Capture state reset (capturedImage set to nil).")
            // Should the session restart here? Let HomeView's onChange handle it.
        }
    }
}

// --- AVCapturePhotoCaptureDelegate Implementation ---
// Create a separate class to handle the delegate callbacks cleanly.
class PhotoCaptureProcessor: NSObject, AVCapturePhotoCaptureDelegate {
    // Completion handler to call back with the processed image
    private var completionHandler: (UIImage?) -> Void

    init(completion: @escaping (UIImage?) -> Void) {
        self.completionHandler = completion
        print("PhotoCaptureProcessor: Initialized.")
    }

    // This delegate method is called when the photo processing is complete
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        print("PhotoCaptureProcessor: didFinishProcessingPhoto called.")
        if let error = error {
            print("PhotoCaptureProcessor Error: Error capturing photo: \(error.localizedDescription)")
            completionHandler(nil)
            return
        }

        // Get image data
        guard let imageData = photo.fileDataRepresentation() else {
            print("PhotoCaptureProcessor Error: Could not get image data representation.")
            completionHandler(nil)
            return
        }

        // Create UIImage
        guard let capturedImage = UIImage(data: imageData) else {
             print("PhotoCaptureProcessor Error: Could not create UIImage from data.")
             completionHandler(nil)
             return
        }
        
        print("PhotoCaptureProcessor: Successfully processed photo into UIImage.")
        // Call the completion handler with the successful image
        completionHandler(capturedImage)
    }
    
     // You might implement other delegate methods if needed (e.g., willBeginCapture, didFinishCapture)
     func photoOutput(_ output: AVCapturePhotoOutput, willBeginCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings) {
         print("PhotoCaptureProcessor: willBeginCapture...")
         // E.g., Trigger shutter sound or visual feedback
     }

     func photoOutput(_ output: AVCapturePhotoOutput, didFinishCaptureFor resolvedSettings: AVCaptureResolvedPhotoSettings, error: Error?) {
         if let error = error {
             print("PhotoCaptureProcessor: didFinishCapture with error: \(error)")
         } else {
             print("PhotoCaptureProcessor: didFinishCapture successfully.")
             // E.g., Stop shutter sound/visual feedback
         }
     }
}

--- File End: ios-app/BrickAI/BrickAI/Managers/CameraManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/ImageDataManager.swift ---
// MARK: MODIFIED FILE - Managers/ImageDataManager.swift
// File: BrickAI/Managers/ImageDataManager.swift
// Manages fetching the image list and preloading/caching image data.
// Updated prepareImageData to avoid clearing images prematurely during refresh.

import Foundation
import SwiftUI // For UIImage and ObservableObject
import Combine // For ObservableObject

@MainActor // Ensures @Published properties are updated on the main thread
class ImageDataManager: ObservableObject {

    // --- Published Properties for UI ---
    @Published var images: [ImageData] = []
    @Published var isLoadingList: Bool = false
    @Published var listError: NetworkError? = nil
    // Optional: Progress for preloading, could be 0.0 to 1.0
    @Published var preloadingProgress: Double = 0.0
    @Published var isPreloading: Bool = false

    // --- Caching ---
    private let imageCache = NSCache<NSURL, UIImage>()
    private let imagePreloadLimit = 20 // Configurable limit for preloading

    // --- Internal State ---
    private var fetchTask: Task<Void, Never>? = nil
    private var preloadTask: Task<Void, Never>? = nil
    private var activeDownloads = Set<URL>() // Track URLs currently being downloaded

    init() {
        print("ImageDataManager: Initialized.")
        // Configure cache limits if needed (defaults are usually okay)
        // imageCache.countLimit = 50 // Example: Max 50 images in cache
        // imageCache.totalCostLimit = 1024 * 1024 * 100 // Example: Max 100MB cache size
    }

    // --- Public Methods ---

    /// Called after login or for refresh to fetch the image list and then preload images.
    func prepareImageData() {
        // Cancel existing tasks to avoid redundant work if called multiple times
        // Keep previous fetchTask cancellation, but potentially allow preload to continue?
        // For simplicity/safety, let's still cancel previous preload on a new list fetch request.
        fetchTask?.cancel()
        preloadTask?.cancel()
        // Don't clear activeDownloads here if we want downloads for older list items potentially completing?
        // Let's keep it cleared for now to ensure preload focuses on the *new* list's priority items.
        activeDownloads.removeAll()
        isPreloading = false // Reset preloading state indicators
        preloadingProgress = 0.0

        print("ImageDataManager: prepareImageData() called. Starting fetch task.")

        // MARK: <<< MODIFIED START >>>
        // Reset only error and loading state, keep existing images for smoother refresh
        // self.images = [] // REMOVED - Avoid clearing images here
        self.listError = nil
        self.isLoadingList = true
        // MARK: <<< MODIFIED END >>>

        fetchTask = Task {
            do {
                // Use await for the Result-based fetchImages
                let fetchedImages = try await fetchImagesWithAsyncAwait()

                // Check if task was cancelled before updating state
                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before updating images.")
                    isLoadingList = false // Still need to turn off loading indicator
                    return
                }

                print("ImageDataManager: Successfully fetched \(fetchedImages.count) images.")
                // MARK: <<< MODIFIED START >>>
                // Update the images array only *after* successful fetch
                self.images = fetchedImages
                // Error is already nil from start of function
                // MARK: <<< MODIFIED END >>>
                self.isLoadingList = false // Finished loading list

                // Start preloading *after* list is successfully fetched and updated
                triggerImagePreloading()

            } catch let error as NetworkError {
                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before handling error.")
                    isLoadingList = false
                    return
                }
                print("ImageDataManager: Error fetching images: \(error.localizedDescription ?? "Unknown error")")
                // MARK: <<< MODIFIED START >>>
                // Don't clear images on error during refresh, keep stale data showing
                // self.images = [] // REMOVED
                // MARK: <<< MODIFIED END >>>
                self.listError = error
                self.isLoadingList = false
            } catch {
                guard !Task.isCancelled else {
                    print("ImageDataManager: Fetch task cancelled before handling unknown error.")
                    isLoadingList = false
                    return
                }
                print("ImageDataManager: Unknown error during image fetch: \(error)")
                // MARK: <<< MODIFIED START >>>
                // Don't clear images on error during refresh
                // self.images = [] // REMOVED
                // MARK: <<< MODIFIED END >>>
                self.listError = .unexpectedResponse // Or a more generic error
                self.isLoadingList = false
            }
        }
    }

    /// Retrieves an image from the cache. Returns nil if not cached.
    func getImage(for url: URL?) -> UIImage? {
        guard let url = url else { return nil }
        return imageCache.object(forKey: url as NSURL)
    }

    /// Attempts to download and cache an image if not already cached or downloading.
    /// Useful for explicitly loading an image that wasn't in the top `imagePreloadLimit`.
    func ensureImageIsCached(for url: URL?) {
        guard let url = url else { return }
        // Check cache first
        if getImage(for: url) != nil { return }
        // Check if already downloading (part of preload or another explicit request)
        guard !activeDownloads.contains(url) else { return }

        print("ImageDataManager: Explicitly caching image for URL: \(url.lastPathComponent)")
        activeDownloads.insert(url)

        Task(priority: .background) { // Lower priority for explicit requests?
            defer {
                // Ensure we remove from activeDownloads even if download fails
                // Use Task to hop back to main actor for safe mutation
                Task { @MainActor in self.activeDownloads.remove(url) }
            }
            if let image = await downloadImage(url: url) {
                 // Add to cache (thread safe)
                self.imageCache.setObject(image, forKey: url as NSURL)
                print("ImageDataManager: Successfully cached explicit request: \(url.lastPathComponent)")
            }
            // No need to update progress for explicit caching
        }
    }


    // --- Private Helper Methods ---

    /// Wraps the NetworkManager's completion-handler based fetch in an async function.
    private func fetchImagesWithAsyncAwait() async throws -> [ImageData] {
        try await withCheckedThrowingContinuation { continuation in
            NetworkManager.fetchImages { result in
                switch result {
                case .success(let images):
                    continuation.resume(returning: images)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Initiates the background task to preload images.
    private func triggerImagePreloading() {
        preloadTask?.cancel() // Cancel any previous preload task
        activeDownloads.removeAll() // Clear active downloads for the new preload cycle
        isPreloading = true // Indicate preloading has started
        preloadingProgress = 0.0 // Reset progress

        // Get the list of images to preload based on the latest fetched data
        let imagesToPreload = Array(images.prefix(imagePreloadLimit))
        guard !imagesToPreload.isEmpty else {
            print("ImageDataManager: No images to preload.")
            isPreloading = false // Nothing to preload
            return
        }
        let totalToPreload = imagesToPreload.count
        var successfullyPreloadedCount = 0 // Track successful downloads *in this cycle*

        print("ImageDataManager: Starting preload task for up to \(totalToPreload) images.")

        preloadTask = Task(priority: .background) { // Run preloading in background
            for imageData in imagesToPreload {
                 // Check for cancellation before each potential download
                guard !Task.isCancelled else {
                    print("ImageDataManager: Preload task cancelled.")
                    break // Exit the loop
                }

                // Prefer processed, fallback to original
                guard let url = imageData.processedImageUrl ?? imageData.originalImageUrl else {
                    continue // Skip if no valid URL for this item
                }

                // Skip if already cached (This is the key part for refresh logic)
                if getImage(for: url) != nil {
                    print("ImageDataManager: Preload skipping already cached: \(url.lastPathComponent)")
                    // Don't increment successfullyPreloadedCount here, as we didn't download it *now*
                    // Only count actual downloads within this task towards progress? Or count skips too?
                    // Let's adjust progress based on iteration / total items targeted for check.
                    // Alternative: base progress on actual downloads initiated/completed.
                    // Let's keep simple progress: items processed / total items to check.
                    // successfullyPreloadedCount += 1 // If counting skips as progress
                    // updatePreloadProgress(current: successfullyPreloadedCount, total: totalToPreload)
                    continue // Move to the next image
                }

                // Skip if already downloading (shouldn't happen if activeDownloads was cleared, but check anyway)
                guard !activeDownloads.contains(url) else { continue }

                activeDownloads.insert(url) // Mark as downloading *before* starting await
                if let image = await downloadImage(url: url) {
                     // Check for cancellation *after* download but *before* caching
                    guard !Task.isCancelled else {
                         print("ImageDataManager: Preload task cancelled after download, before caching \(url.lastPathComponent).")
                         break
                    }
                    // Add to cache (NSCache is thread safe)
                    imageCache.setObject(image, forKey: url as NSURL)
                    print("ImageDataManager: Preloaded and cached: \(url.lastPathComponent)")
                    successfullyPreloadedCount += 1 // Count successful downloads
                } else {
                    // Download failed (error already logged by downloadImage)
                    print("ImageDataManager: Preload failed for: \(url.lastPathComponent)")
                    // Don't increment success count on failure
                }
                 // Remove from active downloads set after attempt finishes
                 // Use Task @MainActor to safely modify activeDownloads
                Task { @MainActor in activeDownloads.remove(url) }


                // Check for cancellation before updating progress
                guard !Task.isCancelled else {
                     print("ImageDataManager: Preload task cancelled before progress update.")
                     break
                }
                 // Update progress on main thread based on successful downloads
                updatePreloadProgress(current: successfullyPreloadedCount, total: totalToPreload)

            } // End loop

             // Final state update after loop finishes or breaks
            Task { @MainActor in
                 // Calculate final progress based on successful downloads vs total targeted (could be < 1.0 if some failed/skipped)
                 let finalProgress = totalToPreload > 0 ? Double(successfullyPreloadedCount) / Double(totalToPreload) : 1.0
                 print("ImageDataManager: Preload task finished. Successfully downloaded \(successfullyPreloadedCount)/\(totalToPreload) target images. Final Progress: \(finalProgress)")
                 self.isPreloading = false // Mark preloading as complete
                 self.preloadingProgress = finalProgress // Set final progress
                 // self.preloadingProgress = 1.0 // Alternative: Always set to 1.0 on completion
                 self.activeDownloads.removeAll() // Ensure clear at the very end
            }
        }
    }

    /// Downloads a single image from a URL.
    private func downloadImage(url: URL) async -> UIImage? {
        do {
            // Use default URLSession; configure cache policy if needed
            // Consider .reloadIgnoringLocalCacheData if backend images might update under same URL? Unlikely for S3.
            let request = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad) // Standard policy
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                print("ImageDataManager: Failed to download image from \(url.lastPathComponent) - Status: \((response as? HTTPURLResponse)?.statusCode ?? 0)")
                return nil
            }

            guard let image = UIImage(data: data) else {
                 print("ImageDataManager: Failed to create UIImage from downloaded data for \(url.lastPathComponent)")
                 return nil
            }
            return image
        } catch {
             // Handle cancellation error specifically
            if (error as? URLError)?.code == .cancelled {
                 print("ImageDataManager: Download cancelled for \(url.lastPathComponent).")
            } else {
                 print("ImageDataManager: Error downloading image \(url.lastPathComponent): \(error.localizedDescription)")
            }
            return nil
        }
    }

    /// Updates the preloading progress (ensures it runs on main thread).
    private func updatePreloadProgress(current: Int, total: Int) {
        guard total > 0 else { return }
        // Calculate progress based on successful downloads vs total items targeted
        let progress = Double(current) / Double(total)
        self.preloadingProgress = progress
        // print("ImageDataManager: Preload progress: \(progress * 100)%") // Optional verbose log
    }

    // Optional: Method to clear cache if needed (e.g., on logout)
    func clearCache() {
        imageCache.removeAllObjects()
        activeDownloads.removeAll() // Cancel any in-flight downloads associated with cache
        isPreloading = false
        preloadTask?.cancel() // Cancel the preload task itself
        print("ImageDataManager: Image cache cleared.")
    }
}
// MARK: END MODIFIED FILE - Managers/ImageDataManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/ImageDataManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/KeychainService.swift ---
// File: BrickAI/Managers/KeychainService.swift
// Full Untruncated File

import Foundation
import Security

// Service identifier for Keychain items specific to this app
// Using the bundle ID is a common practice to avoid collisions
let kKeychainService = Bundle.main.bundleIdentifier ?? "com.default.keychainservice"

// Account keys used to identify specific data items
let kKeychainAccountUserIdentifier = "appleUserIdentifier"
// DEPRECATED - let kKeychainAccountIdentityToken = "appleIdentityToken" // No longer storing Apple identity token directly
let kKeychainAccountSessionToken = "backendSessionToken" // Key for storing our backend session token
let kKeychainAccountUserName = "userName" // Can also store username if desired

enum KeychainError: Error, LocalizedError {
    case itemNotFound
    case duplicateItem // Although we try to avoid this with delete-then-add or update
    case unexpectedData
    case unhandledError(status: OSStatus)

    var errorDescription: String? {
        switch self {
        case .itemNotFound:
            return "Keychain item not found."
        case .duplicateItem:
            return "Keychain item already exists."
        case .unexpectedData:
            return "Unexpected data format retrieved from Keychain."
        case .unhandledError(let status):
            // Provide a more descriptive error if possible using SecCopyErrorMessageString
            // However, that function is not available on all platforms/versions directly in Swift easily.
            return "Keychain operation failed with OSStatus: \(status)"
        }
    }
}

struct KeychainService {

    // Generic function to save data to Keychain
    static func saveData(_ data: Data, forKey accountKey: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey,
            kSecValueData as String: data,
            // Set accessibility - item accessible only when device is unlocked
            // This is a reasonable default for user credentials/tokens.
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        // Delete existing item first to ensure we replace it cleanly.
        // This simplifies the logic compared to checking existence then deciding Add vs Update.
        // Ignore itemNotFound error during delete, as it means we're just adding fresh.
        do {
            try deleteData(forKey: accountKey)
        } catch KeychainError.itemNotFound {
            // This is expected if the item doesn't exist yet. Continue to add.
        } catch {
             // Rethrow other unexpected delete errors
             throw error
        }


        // Add the new item
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            // If deletion failed silently and we hit duplicate, something is wrong.
            print("Keychain: Error saving data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
         print("Keychain: Successfully saved data for key '\(accountKey)'")
    }

    // Generic function to load data from Keychain
    static func loadData(forKey accountKey: String) throws -> Data {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey,
            kSecMatchLimit as String: kSecMatchLimitOne,  // We expect only one item per key
            kSecReturnData as String: kCFBooleanTrue!     // Request data back
        ]

        var item: CFTypeRef? // Use CFTypeRef for the result
        let status = SecItemCopyMatching(query as CFDictionary, &item)

        // Check for specific errors
        guard status != errSecItemNotFound else {
            throw KeychainError.itemNotFound
        }
        // Check for generic success
        guard status == errSecSuccess else {
            print("Keychain: Error loading data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
        // Check if the retrieved item is actually Data
        guard let data = item as? Data else {
            // This indicates an unexpected item type was stored or retrieved
            throw KeychainError.unexpectedData
        }

        print("Keychain: Successfully loaded data for key '\(accountKey)'")
        return data
    }

    // Generic function to update existing data in Keychain (Less used with delete-then-add strategy)
    // Kept for completeness or alternative implementations.
    static func updateData(_ data: Data, forKey accountKey: String) throws {
         let query: [String: Any] = [
             kSecClass as String: kSecClassGenericPassword,
             kSecAttrService as String: kKeychainService,
             kSecAttrAccount as String: accountKey
             // Do not specify kSecMatchLimitOne for update
         ]

         // Attributes to update
         let attributes: [String: Any] = [
             kSecValueData as String: data
             // Could potentially update kSecAttrAccessible here too if needed
         ]

         let status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)
         // Check specific errors
         guard status != errSecItemNotFound else {
             // Cannot update an item that doesn't exist
             throw KeychainError.itemNotFound
         }
         // Check generic success
         guard status == errSecSuccess else {
            print("Keychain: Error updating data for key '\(accountKey)'. Status: \(status)")
             throw KeychainError.unhandledError(status: status)
         }
          print("Keychain: Successfully updated data for key '\(accountKey)'")
     }


    // Generic function to delete data from Keychain
    static func deleteData(forKey accountKey: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: kKeychainService,
            kSecAttrAccount as String: accountKey
            // No kSecMatchLimit needed for delete (deletes all matching if multiple existed, though our keys should be unique)
        ]

        let status = SecItemDelete(query as CFDictionary)
        // Treat itemNotFound as success (idempotent delete)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            print("Keychain: Error deleting data for key '\(accountKey)'. Status: \(status)")
            throw KeychainError.unhandledError(status: status)
        }
         if status == errSecSuccess {
              print("Keychain: Successfully deleted data for key '\(accountKey)'")
         } else {
              // This log might be redundant if throwing itemNotFound, but useful for clarity
              print("Keychain: No data found to delete for key '\(accountKey)'")
         }
    }

    // --- Convenience methods for String ---

    static func saveString(_ string: String, forKey accountKey: String) throws {
        // Convert String to Data using UTF-8 encoding
        guard let data = string.data(using: .utf8) else {
            print("Error converting string to data for key: \(accountKey)")
            // Throw an appropriate error if conversion fails
            throw KeychainError.unexpectedData // Or a more specific encoding error
        }
        // Call the primary saveData function
        try saveData(data, forKey: accountKey)
    }

    static func loadString(forKey accountKey: String) -> String? {
        do {
            // Call the primary loadData function
            let data = try loadData(forKey: accountKey)
            // Convert retrieved Data back to String using UTF-8
            return String(data: data, encoding: .utf8)
        } catch KeychainError.itemNotFound {
            // Item not found is often an expected case during loading, return nil
            print("Keychain: No string found for key '\(accountKey)'")
            return nil
        } catch {
            // Log other unexpected errors during loading
            print("Keychain: Failed to load string for key '\(accountKey)': \(error.localizedDescription)")
            return nil // Return nil on other errors
        }
    }
}
--- File End: ios-app/BrickAI/BrickAI/Managers/KeychainService.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/NetworkManager.swift ---
// MARK: MODIFIED FILE - Managers/NetworkManager.swift
// File: BrickAI/Managers/NetworkManager.swift
// Full Untruncated File - Added Equatable conformance to NetworkError.

import Foundation
import UIKit

// MARK: <<< MODIFIED START >>>
// NetworkError Enum - Added Equatable conformance
enum NetworkError: Error, LocalizedError, Equatable {
// MARK: <<< MODIFIED END >>>
    case invalidURL(String)
    case dataConversionFailed
    case authenticationTokenMissing
    case networkRequestFailed(Error)
    case serverError(statusCode: Int, message: String?)
    case unauthorized // Specific 401 before refresh attempt
    case unexpectedResponse
    case authCodeExchangeFailed(String)
    case tokenRefreshFailed(String)
    case sessionExpired // Terminal refresh failure

    var errorDescription: String? {
        switch self {
        case .invalidURL(let urlString): return "The configured API endpoint URL is invalid: \(urlString)"
        case .dataConversionFailed: return "Failed to convert image to data format."
        case .authenticationTokenMissing: return "User authentication token is missing. Please log in."
        case .networkRequestFailed(let underlyingError): return "Network request failed: \(underlyingError.localizedDescription)"
        case .serverError(let statusCode, let message):
             var desc = "Server returned an error (Status Code: \(statusCode))."
             if let msg = message, !msg.isEmpty { desc += " Message: \(msg)" }
             return desc
        case .unauthorized: return "Unauthorized: Session may require refresh."
        case .unexpectedResponse: return "Received an unexpected response format from the server."
        case .authCodeExchangeFailed(let message): return "Failed to exchange authorization code with backend: \(message)"
        case .tokenRefreshFailed(let message): return "Failed to refresh session token: \(message)"
        case .sessionExpired: return "Your session has expired. Please log in again."
        }
    }

    // MARK: <<< ADDED START >>>
    // Implementation of Equatable conformance
    static func == (lhs: NetworkError, rhs: NetworkError) -> Bool {
        switch (lhs, rhs) {
        case (.invalidURL(let lhsString), .invalidURL(let rhsString)):
            return lhsString == rhsString
        case (.dataConversionFailed, .dataConversionFailed):
            return true
        case (.authenticationTokenMissing, .authenticationTokenMissing):
            return true
        case (.networkRequestFailed(let lhsError), .networkRequestFailed(let rhsError)):
            // Comparing actual Error objects is difficult.
            // Compare based on localizedDescription for pragmatic equality check.
            return lhsError.localizedDescription == rhsError.localizedDescription
        case (.serverError(let lhsCode, let lhsMessage), .serverError(let rhsCode, let rhsMessage)):
            return lhsCode == rhsCode && lhsMessage == rhsMessage
        case (.unauthorized, .unauthorized):
            return true
        case (.unexpectedResponse, .unexpectedResponse):
            return true
        case (.authCodeExchangeFailed(let lhsMessage), .authCodeExchangeFailed(let rhsMessage)):
            return lhsMessage == rhsMessage
        case (.tokenRefreshFailed(let lhsMessage), .tokenRefreshFailed(let rhsMessage)):
            return lhsMessage == rhsMessage
        case (.sessionExpired, .sessionExpired):
            return true
        // If none of the cases match, they are not equal
        default:
            return false
        }
    }
    // MARK: <<< ADDED END >>>
}

// Actor to manage the refresh token state and prevent race conditions
actor TokenRefresher {
    private var isRefreshing = false
    // Stores continuations waiting for the refresh to complete
    private var waitingContinuations: [CheckedContinuation<String, Error>] = []

    // Attempts to refresh the token, ensuring only one refresh happens at a time.
    func refreshTokenIfNeeded() async throws -> String {
        if !isRefreshing {
            isRefreshing = true
            // Perform the actual refresh network call
            do {
                // IMPORTANT: Call the static function on NetworkManager, not directly accessing self
                let newToken = try await NetworkManager.performTokenRefresh()

                // Notify all waiting tasks with the new token - this runs on the actor
                waitingContinuations.forEach { $0.resume(returning: newToken) }
                waitingContinuations.removeAll()
                isRefreshing = false
                print("TokenRefresher: Refresh successful, notified \(waitingContinuations.count) waiters.")
                return newToken
            } catch {
                // Notify all waiting tasks about the failure - this runs on the actor
                print("TokenRefresher: Refresh failed, notifying \(waitingContinuations.count) waiters.")
                waitingContinuations.forEach { $0.resume(throwing: error) }
                waitingContinuations.removeAll()
                isRefreshing = false
                throw error // Re-throw the error
            }
        } else {
            // If already refreshing, wait for the result
            print("TokenRefresher: Refresh already in progress, waiting...")
            return try await withCheckedThrowingContinuation { continuation in
                 // Accessing actor state directly inside the actor's async function.
                 // The continuation itself is Sendable.
                 self.waitingContinuations.append(continuation)
            }
        }
    }
} // End Actor


class NetworkManager {

    private static let tokenRefresher = TokenRefresher() // Instance of the actor

    private static var jsonDecoder: JSONDecoder = {
        let decoder = JSONDecoder()
        // Use a custom formatter that handles fractional seconds and timezone
        decoder.dateDecodingStrategy = .formatted(DateFormatter.iso8601Full)
        return decoder
    }()
    
    private static var baseApiEndpointURL: URL? {
        guard let urlString = Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String else { return nil }
        let correctedUrlString = urlString.hasSuffix("/") ? urlString : urlString + "/"
        guard let url = URL(string: correctedUrlString) else { return nil }
        return url
    }
    
    private static func endpointURL(path: String) -> URL? {
        let correctedPath = path.starts(with: "/") ? String(path.dropFirst()) : path
        return baseApiEndpointURL?.appendingPathComponent(correctedPath)
    }

    // Centralized Request Execution Function
    private static func performRequest(
        originalRequest: URLRequest,
        completion: @escaping (Result<Data, NetworkError>) -> Void
    ) {
        let mainThreadCompletion = { result in DispatchQueue.main.async { completion(result) } }

        guard let token = UserManager.shared.getSessionToken() else {
            mainThreadCompletion(.failure(.authenticationTokenMissing))
            return
        }
        var request = originalRequest
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                mainThreadCompletion(.failure(.networkRequestFailed(error)))
                return
            }
            guard let httpResponse = response as? HTTPURLResponse else {
                mainThreadCompletion(.failure(.serverError(statusCode: 0, message: "Invalid response type")))
                return
            }

            // Check for Unauthorized (401)
            if httpResponse.statusCode == 401 {
                print("NetworkManager: Received 401 Unauthorized for \(request.url?.absoluteString ?? "URL"). Attempting token refresh...")
                Task { // Use Task to call async actor function
                    do {
                        // Call the actor method
                        let newToken = try await tokenRefresher.refreshTokenIfNeeded()
                        print("NetworkManager: Token refresh successful via actor. Retrying original request...")

                        var retryRequest = originalRequest // Use original request
                        retryRequest.setValue("Bearer \(newToken)", forHTTPHeaderField: "Authorization") // Set NEW token

                        // Retry the request
                        let retryTask = URLSession.shared.dataTask(with: retryRequest) { retryData, retryResponse, retryError in
                            if let retryError = retryError {
                                mainThreadCompletion(.failure(.networkRequestFailed(retryError)))
                                return
                            }
                            guard let retryHttpResponse = retryResponse as? HTTPURLResponse else {
                                mainThreadCompletion(.failure(.serverError(statusCode: 0, message: "Invalid retry response type")))
                                return
                            }

                            if retryHttpResponse.statusCode == 401 { // If retry STILL fails with 401
                                print("NetworkManager: Retry request failed with 401. Session expired.")
                                UserManager.shared.clearUser()
                                mainThreadCompletion(.failure(.sessionExpired))
                                return
                            }
                            guard (200...299).contains(retryHttpResponse.statusCode) else {
                                let errorMessage = parseError(from: retryData, statusCode: retryHttpResponse.statusCode)
                                mainThreadCompletion(.failure(.serverError(statusCode: retryHttpResponse.statusCode, message: errorMessage)))
                                return
                            }
                            // Retry succeeded
                            mainThreadCompletion(.success(retryData ?? Data()))
                        }
                        retryTask.resume()

                    } catch let refreshError as NetworkError {
                        print("NetworkManager: Token refresh failed: \(refreshError.localizedDescription)")
                        if case .sessionExpired = refreshError { UserManager.shared.clearUser() }
                        mainThreadCompletion(.failure(refreshError))
                    } catch {
                        print("NetworkManager: Unexpected error during token refresh: \(error.localizedDescription)")
                        mainThreadCompletion(.failure(.tokenRefreshFailed("Unexpected error during refresh.")))
                    }
                } // End Task
            } else { // Not a 401 error
                guard (200...299).contains(httpResponse.statusCode) else {
                    let errorMessage = parseError(from: data, statusCode: httpResponse.statusCode)
                    mainThreadCompletion(.failure(.serverError(statusCode: httpResponse.statusCode, message: errorMessage)))
                    return
                }
                // Request succeeded on first try
                mainThreadCompletion(.success(data ?? Data()))
            }
        }
        task.resume()
    }

    // Internal function to perform the actual token refresh API call
    static func performTokenRefresh() async throws -> String {
        print("NetworkManager: Executing performTokenRefresh...")
        guard let refreshURL = endpointURL(path: "api/auth/refresh") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/auth/refresh"
            throw NetworkError.invalidURL(urlString)
        }
        guard let currentToken = UserManager.shared.getSessionToken() else { throw NetworkError.authenticationTokenMissing }

        var request = URLRequest(url: refreshURL)
        request.httpMethod = "POST"
        request.setValue("Bearer \(currentToken)", forHTTPHeaderField: "Authorization")

        let data: Data
        let response: URLResponse
        do {
            (data, response) = try await URLSession.shared.data(for: request)
        } catch {
            throw NetworkError.networkRequestFailed(error)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.serverError(statusCode: 0, message: "Invalid response type")
        }

        if httpResponse.statusCode == 401 {
            throw NetworkError.sessionExpired // Treat 401 from refresh endpoint as session expired
        }
        guard (200...299).contains(httpResponse.statusCode) else {
            let errorMessage = parseError(from: data, statusCode: httpResponse.statusCode)
            throw NetworkError.tokenRefreshFailed(errorMessage)
        }

        // Parse success response
        do {
            if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let newToken = jsonResponse["sessionToken"] as? String {
                UserManager.shared.updateSessionToken(newToken: newToken) // Update Keychain
                print("NetworkManager: Successfully received and saved new session token.")
                return newToken
            } else {
                throw NetworkError.unexpectedResponse
            }
        } catch {
            throw NetworkError.unexpectedResponse
        }
    }

    // Helper to parse error messages
    private static func parseError(from data: Data?, statusCode: Int) -> String {
        guard let data = data else { return "No error details provided." }
        do {
            if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let errorMsg = json["error"] as? String {
                return errorMsg
            }
        } catch {
            // Ignore
        }
        return String(data: data, encoding: .utf8) ?? "Could not decode error message."
    }

    // Public API Functions
    static func uploadImage(_ image: UIImage, completion: @escaping (Result<String, NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/upload") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/upload"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            DispatchQueue.main.async { completion(.failure(.dataConversionFailed)) }
            return
        }
        
        var request = URLRequest(url: endpoint)
        request.httpMethod = "POST"
        request.setValue("image/jpeg", forHTTPHeaderField: "Content-Type")
        request.httpBody = imageData

        performRequest(originalRequest: request) { result in
            switch result {
            case .success(let data):
                do {
                    if let jsonResponse = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let urlString = jsonResponse["url"] as? String {
                        completion(.success(urlString))
                    } else {
                        completion(.failure(.unexpectedResponse))
                    }
                } catch {
                    completion(.failure(.unexpectedResponse))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    // exchangeAuthCode remains separate
    static func exchangeAuthCode(authorizationCode: String, completion: @escaping (Result<String, NetworkError>) -> Void) {
        guard let authCallbackURL = endpointURL(path: "api/auth/apple/callback") else {
            let urlString = (Bundle.main.object(forInfoDictionaryKey: "APIEndpointURL") as? String ?? "NF") + "/api/auth/apple/callback"
            DispatchQueue.main.async { completion(.failure(.invalidURL(urlString))) }
            return
        }
        
        let requestBody: [String: String] = ["authorizationCode": authorizationCode]
        guard let jsonData = try? JSONEncoder().encode(requestBody) else {
            DispatchQueue.main.async { completion(.failure(.authCodeExchangeFailed("Failed to encode request."))) }
            return
        }
        
        var request = URLRequest(url: authCallbackURL)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(.networkRequestFailed(error)))
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    completion(.failure(.serverError(statusCode: 0, message: "Invalid response type")))
                    return
                }
                
                guard let responseData = data else {
                    completion(.failure(.serverError(statusCode: httpResponse.statusCode, message: "Missing response data.")))
                    return
                }
                
                var serverMessage: String? = nil
                var sessionToken: String? = nil
                
                do {
                    if let jsonResponse = try JSONSerialization.jsonObject(with: responseData) as? [String: Any] {
                        serverMessage = jsonResponse["error"] as? String ?? jsonResponse["message"] as? String
                        sessionToken = jsonResponse["sessionToken"] as? String
                    } else {
                        serverMessage = String(data: responseData, encoding: .utf8)
                    }
                } catch {
                    serverMessage = String(data: responseData, encoding: .utf8)
                }
                
                if (200...299).contains(httpResponse.statusCode), let token = sessionToken {
                    completion(.success(token))
                } else {
                    let errorMessage = serverMessage ?? "Auth code exchange failed status \(httpResponse.statusCode)."
                    completion(.failure(.authCodeExchangeFailed(errorMessage)))
                }
            }
        }
        task.resume()
    }

    static func fetchImages(completion: @escaping (Result<[ImageData], NetworkError>) -> Void) {
        guard let endpoint = endpointURL(path: "api/images") else {
            DispatchQueue.main.async { completion(.failure(.invalidURL("images"))) }
            return
        }
        
        var request = URLRequest(url: endpoint)
        request.httpMethod = "GET"
        print("NetworkManager: Fetching images...")
        
        performRequest(originalRequest: request) { result in
            switch result {
            case .success(let data):
                do {
                    let images = try jsonDecoder.decode([ImageData].self, from: data)
                    print("NetworkManager: Successfully fetched and decoded \(images.count) images.")
                    completion(.success(images))
                } catch {
                    print("NetworkManager: Failed to decode images JSON: \(error)")
                    completion(.failure(.unexpectedResponse))
                }
            case .failure(let error):
                print("NetworkManager: Failed to fetch images: \(error.localizedDescription)")
                completion(.failure(error))
            }
        }
    }
}

extension DateFormatter {
  static let iso8601Full: DateFormatter = {
    let formatter = DateFormatter()
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ" // Format with fractional seconds and timezone
    formatter.calendar = Calendar(identifier: .iso8601)
    formatter.timeZone = TimeZone(secondsFromGMT: 0) // Assume UTC or parse timezone from string
    formatter.locale = Locale(identifier: "en_US_POSIX") // Essential for fixed formats
    return formatter
  }()
}
// MARK: END MODIFIED FILE - Managers/NetworkManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/NetworkManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Managers/UserManager.swift ---
// MARK: MODIFIED FILE - Managers/UserManager.swift
// File: BrickAI/Managers/UserManager.swift
// Removed direct dependency on ImageDataManager

import Foundation
import Combine

class UserManager: ObservableObject {
    static let shared = UserManager() // Keep as singleton for easy access if needed elsewhere, but LoginView uses EnvironmentObject

    @Published private(set) var userName: String?
    @Published private(set) var userIdentifier: String?
    @Published private(set) var isLoggedIn: Bool = false

    // MARK: <<< REMOVED START >>>
    // Remove the ImageDataManager property and related calls
    // private var imageDataManager = ImageDataManager() // REMOVED
    // MARK: <<< REMOVED END >>>

    private init() {
        self.userIdentifier = KeychainService.loadString(forKey: kKeychainAccountUserIdentifier)
        self.userName = KeychainService.loadString(forKey: kKeychainAccountUserName)
        let sessionToken = KeychainService.loadString(forKey: kKeychainAccountSessionToken)
        self.isLoggedIn = (self.userIdentifier != nil && !self.userIdentifier!.isEmpty && sessionToken != nil && !sessionToken!.isEmpty)
        print("UserManager Initialized. UserIdentifier loaded: \(self.userIdentifier != nil), UserName loaded: \(self.userName != nil), SessionToken loaded: \(sessionToken != nil). Determined isLoggedIn: \(self.isLoggedIn)")

        // MARK: <<< REMOVED START >>>
        // Remove trigger from init
        /*
        if self.isLoggedIn {
            print("UserManager: User already logged in on init. Triggering image data preparation.")
             Task { @MainActor in
                  imageDataManager.prepareImageData()
             }
        }
        */
        // MARK: <<< REMOVED END >>>
    }

    // Save initial credentials and session token
    func saveCredentials(userName: String?, userIdentifier: String, sessionToken: String) {
        do {
            try KeychainService.saveString(userIdentifier, forKey: kKeychainAccountUserIdentifier)
            if let name = userName, !name.isEmpty {
                try KeychainService.saveString(name, forKey: kKeychainAccountUserName)
            } else {
                try? KeychainService.deleteData(forKey: kKeychainAccountUserName)
            }
            try KeychainService.saveString(sessionToken, forKey: kKeychainAccountSessionToken)

            // MARK: <<< REMOVED START >>>
            // let wasAlreadyLoggedIn = self.isLoggedIn // No longer needed here
            // MARK: <<< REMOVED END >>>

            DispatchQueue.main.async {
                self.userIdentifier = userIdentifier
                self.userName = userName
                self.isLoggedIn = true
                print("UserManager: Credentials and session token saved successfully. isLoggedIn set to true.")

                // MARK: <<< REMOVED START >>>
                // Remove trigger from saveCredentials
                /*
                 if !wasAlreadyLoggedIn {
                      print("UserManager: Login successful. Triggering image data preparation.")
                      self.imageDataManager.prepareImageData()
                 }
                */
                 // MARK: <<< REMOVED END >>>
            }
        } catch {
            print("UserManager: Failed to save credentials/session token to Keychain: \(error.localizedDescription)")
            DispatchQueue.main.async { self.clearUser() }
        }
    }

    // Retrieve the current backend session token (Unchanged)
    func getSessionToken() -> String? {
        // ... (no changes needed here) ...
        do {
            guard let tokenString = KeychainService.loadString(forKey: kKeychainAccountSessionToken) else {
                throw KeychainError.itemNotFound
            }
            return tokenString
        } catch KeychainError.itemNotFound {
            print("UserManager: Backend session token not found in Keychain.")
            return nil
        } catch {
            print("UserManager: Failed to load backend session token from Keychain: \(error.localizedDescription)")
            return nil
        }
    }

    // Update only the session token after a refresh (Unchanged)
    func updateSessionToken(newToken: String) {
        // ... (no changes needed here) ...
        do {
            try KeychainService.saveString(newToken, forKey: kKeychainAccountSessionToken)
            print("UserManager: Session token updated successfully in Keychain.")
            if !self.isLoggedIn {
                DispatchQueue.main.async {
                    self.userIdentifier = KeychainService.loadString(forKey: kKeychainAccountUserIdentifier)
                    self.isLoggedIn = (self.userIdentifier != nil && !self.userIdentifier!.isEmpty)
                    print("UserManager: Warning - isLoggedIn was false during token update. Resetting based on user ID presence.")
                     // MARK: <<< REMOVED START >>>
                     // Remove trigger from updateSessionToken
                     /*
                     if self.isLoggedIn {
                          print("UserManager: Became logged in during token update. Triggering image data prep.")
                           self.imageDataManager.prepareImageData()
                     }
                    */
                    // MARK: <<< REMOVED END >>>
                }
            }
        } catch {
            print("UserManager: Failed to update session token in Keychain: \(error.localizedDescription)")
        }
    }

    // Clear user data and session token
    func clearUser() {
        // Use try? for non-critical deletions
        try? KeychainService.deleteData(forKey: kKeychainAccountUserIdentifier)
        try? KeychainService.deleteData(forKey: kKeychainAccountSessionToken)
        try? KeychainService.deleteData(forKey: kKeychainAccountUserName)

        DispatchQueue.main.async {
            // MARK: <<< REMOVED START >>>
            // let wasLoggedIn = self.isLoggedIn // No longer needed here
            // MARK: <<< REMOVED END >>>
            self.userIdentifier = nil
            self.userName = nil
            self.isLoggedIn = false
            print("UserManager: User data and session token cleared from Keychain and state updated. isLoggedIn set to false.")
            // MARK: <<< REMOVED START >>>
            // Remove clearCache call from here
            /*
            if wasLoggedIn {
                 print("UserManager: Clearing image cache on logout.")
                 self.imageDataManager.clearCache()
            }
            */
            // MARK: <<< REMOVED END >>>
        }
    }
}
// MARK: END MODIFIED FILE - Managers/UserManager.swift
--- File End: ios-app/BrickAI/BrickAI/Managers/UserManager.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Models/ImageData.swift ---
// File: BrickAI/Models/ImageData.swift
// Modified CodingKeys to expect camelCase JSON from backend

import Foundation

struct ImageData: Codable, Identifiable {
    let id: Int // Matches SERIAL PK
    let status: String
    let prompt: String?
    let createdAt: Date
    let originalImageUrl: URL?
    let processedImageUrl: URL?

    // Coding keys to match JSON *sent by the backend*.
    // If backend sends camelCase (e.g., 'createdAt'), list case without explicit string value.
    // If backend sends snake_case (e.g., 'created_at'), map it like `case propertyName = "json_key"`.
    enum CodingKeys: String, CodingKey {
        case id // Assumes backend sends 'id'
        case status // Assumes backend sends 'status'
        case prompt // Assumes backend sends 'prompt'

        // Adjust these to match the keys ACTUALLY being sent by your /api/images backend:
        // Assuming backend sends camelCase as per its internal mapping object:
        case createdAt
        case originalImageUrl
        case processedImageUrl

        // If backend was sending snake_case (like the corrected version I sent before), you would use:
        // case createdAt = "created_at"
        // case originalImageUrl = "original_image_url"
        // case processedImageUrl = "processed_image_url"
    }
}

// Example for PreviewProvider (remains the same structure, uses Int ID)
extension ImageData {
    static var previewData: [ImageData] {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return [
            ImageData(id: 1, status: "COMPLETED", prompt: "A cat made of bricks", createdAt: Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/0000FF/808080?text=Original+1"), processedImageUrl: URL(string: "https://via.placeholder.com/150/FF0000/FFFFFF?text=Processed+1")),
            ImageData(id: 2, status: "UPLOADED", prompt: "A dog made of bricks", createdAt: formatter.date(from: "2025-04-05T10:30:00.123Z") ?? Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/00FF00/808080?text=Original+2"), processedImageUrl: nil),
            ImageData(id: 3, status: "FAILED", prompt: "A house made of bricks", createdAt: formatter.date(from: "2025-04-04T15:00:00Z") ?? Date(), originalImageUrl: URL(string: "https://via.placeholder.com/150/FFFF00/808080?text=Original+3"), processedImageUrl: nil)
        ]
    }
}

--- File End: ios-app/BrickAI/BrickAI/Models/ImageData.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/CameraLiveView.swift ---
import SwiftUI
import AVFoundation

// Renamed Struct
struct CameraLiveView: UIViewRepresentable {
    let session: AVCaptureSession
     
    func makeUIView(context: Context) -> PreviewView {
        let view = PreviewView()
        view.session = session
        // Ensure the view's frame fills the available space
        view.setContentHuggingPriority(.defaultLow, for: .horizontal)
        view.setContentHuggingPriority(.defaultLow, for: .vertical)
        return view
    }
     
    func updateUIView(_ uiView: PreviewView, context: Context) {
        // If the session changes, update the preview view
        if uiView.session != session {
             uiView.session = session
        }
    }
     
    // Custom UIView subclass remains the same internally
    class PreviewView: UIView {
        var session: AVCaptureSession? {
            didSet {
                guard let session = session else {
                    previewLayer.session = nil
                    return
                }
                // Check if the layer's session needs updating
                 if previewLayer.session != session {
                    previewLayer.session = session
                 }
            }
        }
         
        // The AVCaptureVideoPreviewLayer displays the camera feed.
        // Make it lazy to ensure layerClass is used.
        lazy var previewLayer: AVCaptureVideoPreviewLayer = {
             let layer = AVCaptureVideoPreviewLayer()
             layer.videoGravity = .resizeAspectFill // Fill the layer bounds
             // Set the connection's orientation later in layoutSubviews or updateOrientation
             return layer
         }()


        // Override layerClass to ensure the view's backing layer is a AVCaptureVideoPreviewLayer
        // This is often considered cleaner than adding a sublayer manually.
        // override class var layerClass: AnyClass {
        //     AVCaptureVideoPreviewLayer.self
        // }
        // Note: If using layerClass override, access the layer via `self.layer as! AVCaptureVideoPreviewLayer`.
        // The current sublayer approach is also common and works fine. Let's stick to it for consistency.

         
        override init(frame: CGRect) {
            super.init(frame: frame)
            setupPreviewLayer()
        }
         
        required init?(coder: NSCoder) {
            super.init(coder: coder)
            setupPreviewLayer()
        }
         
        private func setupPreviewLayer() {
            // If NOT using layerClass override, add the previewLayer as a sublayer
             previewLayer.videoGravity = .resizeAspectFill
             layer.addSublayer(previewLayer)
        }
         
        override func layoutSubviews() {
            super.layoutSubviews()
            // Ensure the preview layer always fills the view's bounds
            previewLayer.frame = bounds
            updateOrientation() // Update orientation whenever layout changes
        }
         
        // Update preview orientation based on interface orientation
        private func updateOrientation() {
             guard let connection = previewLayer.connection, connection.isVideoOrientationSupported else { return }
             
             // Get current interface orientation
             // Note: Using UIDevice.current.orientation can be unreliable as it might report faceUp/faceDown.
             // It's often better to use the scene's interface orientation.
             let interfaceOrientation = window?.windowScene?.interfaceOrientation ?? .portrait // Default to portrait

             let videoOrientation: AVCaptureVideoOrientation
             switch interfaceOrientation {
             case .portrait:
                 videoOrientation = .portrait
             case .landscapeLeft:
                 videoOrientation = .landscapeLeft // Map directly
             case .landscapeRight:
                 videoOrientation = .landscapeRight // Map directly
             case .portraitUpsideDown:
                 videoOrientation = .portraitUpsideDown
             case .unknown:
                  videoOrientation = .portrait // Fallback
             @unknown default:
                 videoOrientation = .portrait // Fallback
             }
             
             if connection.videoOrientation != videoOrientation {
                  connection.videoOrientation = videoOrientation
             }
        }
    }
}

--- File End: ios-app/BrickAI/BrickAI/Views/CameraLiveView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/CapturedImageView.swift ---
import SwiftUI

struct CapturedImageView: View {
    let image: UIImage // The captured image to display/upload
    // Access the shared CameraManager instance to reset state
    @StateObject private var cameraManager = CameraManager.shared
    // We no longer need EnvironmentObject for UserManager just to pass the token

    // State variables for managing the upload process and UI feedback
    @State private var isUploading = false
    @State private var uploadError: String? = nil
    @State private var uploadSuccessURL: String? = nil // Store returned URL on success

    var body: some View {
        ZStack {
            // Background
            Color.black.ignoresSafeArea()

            // Display the captured image
            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .ignoresSafeArea()

            // Overlays for controls and status messages
            VStack {
                 // Top row with Cancel ('X') button
                 HStack {
                     Button(action: {
                          // Allow cancelling only if not currently uploading
                          if !isUploading {
                               cameraManager.resetCaptureState() // Dismiss this view by resetting state
                          }
                     }) {
                         Image(systemName: "xmark.circle.fill")
                             .font(.title)
                             .padding()
                             .foregroundColor(.white)
                             .shadow(radius: 3)
                     }
                     .disabled(isUploading) // Disable cancel button during upload
                     .padding() // Add padding around the button
                     Spacer() // Push button to the left
                 }

                 Spacer() // Pushes bottom controls down

                 // Bottom row with Confirm (Checkmark) button
                 HStack(spacing: 60) {
                     Spacer() // Center the button horizontally
                     Button(action: {
                         // --- Trigger Upload Action ---
                         // Set UI state to indicate uploading
                         self.isUploading = true
                         self.uploadError = nil    // Clear previous errors
                         self.uploadSuccessURL = nil // Clear previous success

                         print("CapturedImageView: Upload button tapped. Initiating upload via NetworkManager.")
                         // Call NetworkManager's uploadImage function.
                         // It now retrieves the token internally from UserManager/Keychain.
                         NetworkManager.uploadImage(self.image) { result in
                             // This completion handler runs on the main thread (handled by NetworkManager)
                             self.isUploading = false // Upload finished, update UI state

                             switch result {
                             case .success(let urlString):
                                 // --- Handle Successful Upload ---
                                 print("CapturedImageView: Upload Successful! URL: \(urlString)")
                                 self.uploadSuccessURL = urlString // Store success URL for potential display

                                 // Provide brief success feedback then dismiss the view
                                 DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                     // Check if we are still showing success before dismissing,
                                     // in case user cancelled quickly after success started showing.
                                     if self.uploadSuccessURL == urlString {
                                          cameraManager.resetCaptureState() // Dismiss view
                                     }
                                 }

                             case .failure(let error):
                                 // --- Handle Failed Upload ---
                                 print("CapturedImageView: Upload Failed: \(error.localizedDescription)")
                                 // Display the localized error description from the NetworkError enum
                                 self.uploadError = error.localizedDescription

                                 // Optionally, handle specific errors differently
                                 if case .authenticationTokenMissing = error {
                                      // Suggest user needs to re-login
                                      print("CapturedImageView: Handling authenticationTokenMissing error.")
                                      // Could trigger logout: UserManager.shared.clearUser()
                                 } else if case .unauthorized = error {
                                      // Suggest session expired
                                      print("CapturedImageView: Handling unauthorized error.")
                                 }
                                 // Other errors (.networkRequestFailed, .serverError, etc.) are displayed generically
                             }
                         }
                         // --- End Trigger Upload Action ---
                     }) {
                         // Button content changes based on upload state
                         if isUploading {
                             ProgressView() // Show spinner during upload
                                 .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                 .scaleEffect(2.0) // Make spinner larger
                         } else {
                             Image(systemName: "checkmark.circle.fill") // Show checkmark icon
                                 .font(.system(size: 64))
                                 .foregroundColor(.white)
                                 .shadow(radius: 3)
                         }
                     }
                     .disabled(isUploading) // Disable button while uploading
                     Spacer() // Center the button horizontally
                 }
                 .padding(.bottom, 30) // Space from bottom edge
                 
                 // --- Status Message Area ---
                 // Display error or success message dynamically
                 Group { // Group allows applying modifiers to conditional content
                      if let errorMsg = uploadError {
                          Text(errorMsg)
                              .foregroundColor(.red)
                              .padding(.horizontal)
                              .padding(.vertical, 8)
                              .background(Color.black.opacity(0.75))
                              .cornerRadius(8)
                              .transition(.opacity) // Fade in/out
                              // Optional: Allow tapping error to dismiss it
                              .onTapGesture { self.uploadError = nil }

                      } else if let successURL = uploadSuccessURL {
                          // Display success briefly (handled by dismiss timer mostly)
                           Text("Upload successful!")
                               .foregroundColor(.green)
                               .padding(.horizontal)
                               .padding(.vertical, 8)
                               .background(Color.black.opacity(0.75))
                               .cornerRadius(8)
                               .transition(.opacity) // Fade in/out
                      }
                 }
                 .padding(.bottom, 10) // Space below messages
                 // --- End Status Message Area ---

            } // End VStack for overlays
             // Apply animations to changes in state variables for smoother UI transitions
             .animation(.easeInOut, value: uploadError)
             .animation(.easeInOut, value: uploadSuccessURL)
             .animation(.easeInOut, value: isUploading)

        } // End ZStack (main container)
         .onAppear {
              // Ensure status messages are cleared when the view initially appears
              print("CapturedImageView: Appeared. Clearing status messages.")
              uploadError = nil
              uploadSuccessURL = nil
         }
    }
}

// Previews might require providing a sample image and environment objects if needed
struct CapturedImageView_Previews: PreviewProvider {
     static var previews: some View {
         // Create a placeholder UIImage for the preview
         let placeholderImage = UIImage(systemName: "photo") ?? UIImage()
          CapturedImageView(image: placeholderImage)
              // Inject necessary environment objects or use mock managers for preview
              // .environmentObject(UserManager.shared) // No longer needed for token
              // .environmentObject(CameraManager.shared) // Already using @StateObject
     }
}

--- File End: ios-app/BrickAI/BrickAI/Views/CapturedImageView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/HomeView.swift ---
import SwiftUI
import AVFoundation

struct HomeView: View {
    // Access shared managers
    // Use @StateObject for CameraManager as this view manages its lifecycle (start/stop)
    @StateObject private var cameraManager = CameraManager.shared
    // Use @EnvironmentObject for UserManager if it's provided higher up in the hierarchy
    // If HomeView is the root after login, UserManager might also be @StateObject here.
    // Assuming it's provided via environment:
    @EnvironmentObject var userManager: UserManager

    var body: some View {
         // Use NavigationStack for modern navigation features
         NavigationStack {
             ZStack {
                 // --- Main Content Area ---
                 if cameraManager.isPermissionGranted {
                      // --- Camera Granted Flow ---
                      if let capturedImage = cameraManager.capturedImage {
                          // --- Show Captured Image View ---
                           CapturedImageView(image: capturedImage)
                               // Inject environment objects if CapturedImageView needs them
                               // .environmentObject(userManager) // Example if needed
                               .transition(.asymmetric(insertion: .move(edge: .trailing), removal: .identity)) // Slide in
                      } else {
                           // --- Show Camera Preview and Controls ---
                          CameraLiveView(session: cameraManager.session)
                               .ignoresSafeArea()
                               .transition(.identity) // No transition for the preview itself when appearing
                               .overlay(alignment: .bottom) {
                                     // --- Capture Button ---
                                    Button(action: cameraManager.capturePhoto) { // Directly call capture method
                                         // Standard capture button UI
                                         ZStack {
                                             Circle().fill(.white).frame(width: 65, height: 65)
                                             Circle().stroke(.white, lineWidth: 2).frame(width: 75, height: 75)
                                         }
                                         .shadow(radius: 5)
                                    }
                                    .padding(.bottom, 40) // Adjust spacing from bottom
                               }
                               .overlay(alignment: .topTrailing) {
                                    // --- Settings Button ---
                                     NavigationLink(destination: SettingsView()) { // Assuming SettingsView exists
                                          Image(systemName: "gear")
                                               .font(.title2) // Slightly smaller than title
                                               .foregroundColor(.white)
                                               .padding()
                                               .background(Color.black.opacity(0.5))
                                               .clipShape(Circle())
                                               .shadow(radius: 3)
                                     }
                                     .padding([.top, .trailing]) // Add padding
                               }
                               .overlay(alignment: .bottomTrailing) { // Image List Button remains
                                    NavigationLink(destination: ImageListView()) { Image(systemName: "photo.stack").font(.title2).foregroundColor(.white).padding().background(Color.black.opacity(0.5)).clipShape(Circle()) }
                                        .padding(.bottom, 40).padding(.trailing)
                                }
                      } // End else (show camera preview)
                 } else {
                      // --- Show No Permission View ---
                       NoAccessView(onRequestPermission: cameraManager.requestCameraPermission) // Pass request func
                       .transition(.opacity) // Fade in no access view
                 } // End if permissionGranted

             } // End ZStack
             // --- View Modifiers ---
              .navigationBarHidden(true) // Typically hide nav bar for camera view
              .statusBar(hidden: true) // Often hide status bar too
              .onAppear {
                  print("HomeView: Appeared.")
                  // Check permission status when view appears
                  cameraManager.checkCameraPermission()
                  // Start session only if permission is granted AND no image is currently captured
                  if cameraManager.isPermissionGranted && cameraManager.capturedImage == nil {
                       cameraManager.startSession()
                  }
              }
              .onDisappear {
                   print("HomeView: Disappeared.")
                   // Always stop session when the view disappears entirely
                   cameraManager.stopSession()
              }
              .onChange(of: cameraManager.capturedImage) { oldImage, newImage in
                  // Stop session when an image IS captured, start when it's cleared (if permitted)
                   if newImage != nil {
                       print("HomeView: Image captured, stopping session.")
                       cameraManager.stopSession()
                   } else {
                       // Image was cleared (newImage is nil)
                       print("HomeView: Captured image cleared.")
                       if cameraManager.isPermissionGranted {
                            print("HomeView: Starting session after image clear.")
                            cameraManager.startSession()
                       }
                   }
              }
              .onChange(of: cameraManager.isPermissionGranted) { oldPermission, newPermission in
                   // Handle permission changes while the view is visible
                   if newPermission {
                        // Permission was just granted, start session if no image is captured
                        if cameraManager.capturedImage == nil && !cameraManager.session.isRunning {
                             print("HomeView: Permission granted, starting session.")
                             cameraManager.startSession()
                        }
                   } else {
                        // Permission was just revoked or denied
                         print("HomeView: Permission revoked/denied, stopping session.")
                        cameraManager.stopSession()
                   }
              }
               // Recheck permission status when app comes to foreground
              .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
                   print("HomeView: App will enter foreground, rechecking permission.")
                   cameraManager.checkCameraPermission()
              }
         } // End NavigationStack
    } // End body
}

// --- NoAccessView (Updated to accept action) ---
struct NoAccessView: View {
     var onRequestPermission: () -> Void // Callback to request permission

     var body: some View {
         VStack(spacing: 15) { // Add spacing
             Spacer() // Push content to center
             Image(systemName: "camera.fill") // Use filled icon
                 .font(.system(size: 60))
                 .foregroundColor(.secondary)
                 .padding(.bottom, 10)

             Text("Camera Access Required")
                 .font(.title2)
                 .fontWeight(.semibold)

             Text("Enable camera access in Settings to capture photos.")
                 .font(.subheadline)
                 .foregroundColor(.gray)
                 .multilineTextAlignment(.center)
                 .padding(.horizontal, 40) // Add horizontal padding for text wrapping

             // Button to request permission directly first
             Button("Allow Camera Access", action: onRequestPermission)
                  .padding(.vertical, 10)
                  .padding(.horizontal, 20)
                  .background(Color.blue)
                  .foregroundColor(.white)
                  .cornerRadius(8)
                  .padding(.top)


             // Button to open App Settings as a fallback
             Button("Open App Settings") {
                 if let settingsUrl = URL(string: UIApplication.openSettingsURLString),
                    UIApplication.shared.canOpenURL(settingsUrl) {
                     UIApplication.shared.open(settingsUrl)
                 }
             }
             .font(.footnote) // Make settings link less prominent
             .padding(.top, 5)

             Spacer() // Push content to center
         }
         .frame(maxWidth: .infinity, maxHeight: .infinity) // Fill available space
         .background(Color(.systemBackground)) // Use system background color
     }
}

// --- Preview ---
struct HomeView_Previews: PreviewProvider {
    static var previews: some View {
        HomeView()
            // Provide mock/shared managers for the preview to function
            .environmentObject(UserManager.shared)
            // CameraManager uses @StateObject internally now
    }
}

--- File End: ios-app/BrickAI/BrickAI/Views/HomeView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageDetailView.swift ---
// MARK: MODIFIED FILE - Views/ImageDetailView.swift
// File: BrickAI/Views/ImageDetailView.swift
// Updated to use ImageDataManager cache

import SwiftUI

struct ImageDetailView: View {
    let image: ImageData
    // MARK: <<< ADDED START >>>
    // Get ImageDataManager from environment
    @EnvironmentObject var imageDataManager: ImageDataManager
    // MARK: <<< ADDED END >>>

    var body: some View {
        ScrollView {
            VStack(alignment: .center, spacing: 20) {

                // MARK: <<< MODIFIED START >>>
                // Check cache first
                let imageUrl = image.processedImageUrl ?? image.originalImageUrl
                let cachedImage = imageDataManager.getImage(for: imageUrl)

                Group { // Use Group to apply frame/modifiers consistently
                    if let loadedImage = cachedImage {
                        // Display cached image
                        Image(uiImage: loadedImage)
                            .resizable()
                            .scaledToFit()

                    } else {
                        // Fallback to AsyncImage
                        AsyncImage(url: imageUrl) { phase in
                            switch phase {
                            case .empty:
                                ProgressView()
                                    .frame(height: 300) // Maintain height during load
                            case .success(let loadedImage):
                                loadedImage
                                    .resizable()
                                    .scaledToFit()
                            case .failure:
                                VStack {
                                    Image(systemName: "photo.fill.on.rectangle.fill") // More descriptive icon
                                         .font(.largeTitle)
                                         .foregroundColor(.secondary)
                                    Text("Failed to load image")
                                        .foregroundColor(.secondary)
                                }
                                .frame(height: 300) // Maintain height on failure
                            @unknown default:
                                EmptyView()
                            }
                        }
                         // Trigger explicit cache load if image wasn't preloaded
                         .onAppear {
                              imageDataManager.ensureImageIsCached(for: imageUrl)
                         }
                    }
                }
                .frame(maxWidth: .infinity) // Center AsyncImage/Image content horizontally
                .cornerRadius(10)
                .shadow(radius: 5)
                .padding(.horizontal) // Add horizontal padding if image is narrower than screen
                // MARK: <<< MODIFIED END >>>


                // Details Section
                VStack(alignment: .leading, spacing: 10) {
                    Text("Status: \(image.status.capitalized)")
                        .font(.title2)
                        .fontWeight(.semibold)

                    Divider() // Add divider

                    if let prompt = image.prompt, !prompt.isEmpty {
                        Text("Prompt")
                            .font(.headline)
                        Text(prompt)
                            .font(.body)
                            .foregroundColor(.secondary)
                        Divider()
                    }

                    Text("Uploaded")
                        .font(.headline)
                    // Use formatted styles for better presentation
                    Text(image.createdAt.formatted(date: .long, time: .shortened))
                         .font(.body)
                         .foregroundColor(.secondary)
                }
                .padding(.horizontal) // Padding for text details

                Spacer()
            }
            .padding(.vertical) // Vertical padding for the outer VStack
        }
        .navigationTitle("Image Details")
        .navigationBarTitleDisplayMode(.inline)
         // MARK: <<< ADDED START >>>
         // Inject the environment object needed by this view
         .environmentObject(imageDataManager)
         // MARK: <<< ADDED END >>>
    }
}

// MARK: END MODIFIED FILE - Views/ImageDetailView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageDetailView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/EmptyListView.swift ---
// MARK: ADDED FILE - Views/ImageList/EmptyListView.swift
// File: BrickAI/Views/ImageList/EmptyListView.swift
// Simple view for the empty list state (no images uploaded yet)

import SwiftUI

struct EmptyListView: View {
    var body: some View {
        Text("You haven't uploaded any images yet.")
            .font(.title3) // Slightly larger text
            .foregroundColor(.secondary)
            .frame(maxWidth: .infinity, maxHeight: .infinity) // Center it
            .multilineTextAlignment(.center)
            .padding()
    }
}

struct EmptyListView_Previews: PreviewProvider {
    static var previews: some View {
        EmptyListView()
    }
}
// MARK: END ADDED FILE - Views/ImageList/EmptyListView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/EmptyListView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListContentView.swift ---
// MARK: MODIFIED FILE - Views/ImageList/ImageListContentView.swift
// File: BrickAI/Views/ImageList/ImageListContentView.swift
// Simplified ProgressIndicatorOverlay by removing GeometryReader and using standard overlay alignment.

import SwiftUI

// Extracted overlay view for progress indicators
struct ProgressIndicatorOverlay: View {
    // Receive state values from the parent view
    let isLoadingList: Bool
    let isPreloading: Bool
    let preloadingProgress: Double
    let hasImages: Bool // To determine if refresh indicator should show over existing images

    var body: some View {
        // MARK: <<< MODIFIED START >>>
        // Removed GeometryReader. The view now returns the ZStack/VStack directly.
        // Alignment is handled by the parent's .overlay modifier.
        // Use a VStack to arrange indicators vertically if both could appear (though current logic prevents this).
        // Add padding here to space it from the bottom edge.
        VStack(spacing: 2) {
            // Show spinner during refresh *only if* list already has images
            if isLoadingList && hasImages {
                 ProgressView().scaleEffect(0.8)
                     .padding(.bottom, 5) // Add some padding below spinner
            }

            // Show preloading bar
            if isPreloading {
                 ProgressView(value: preloadingProgress)
                     .progressViewStyle(LinearProgressViewStyle())
                 Text("Preloading recent images...")
                     .font(.caption)
                     .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal) // Horizontal padding for the content
        .padding(.bottom, 8) // Bottom padding from the screen edge
        .frame(maxWidth: .infinity) // Allow VStack to take full width for background/alignment
        // Optional: Add a background for better visibility over list content
        // .background(.thinMaterial) // Example background
        // .cornerRadius(5)
        .transition(.opacity) // Animate appearance
        .allowsHitTesting(false) // Prevent the overlay from blocking touches
        // MARK: <<< MODIFIED END >>>
    }
}


struct ImageListContentView: View {
    // Needs the data manager to get the images and handle refresh
    @EnvironmentObject var imageDataManager: ImageDataManager

    var body: some View {
        // Apply overlay using the extracted view
        List {
            // Iterate over images from the manager
            ForEach(imageDataManager.images) { image in
                 NavigationLink(destination: ImageDetailView(image: image)) {
                      ImageRow(image: image)
                         .environmentObject(imageDataManager) // Pass manager to row
                 }
            }
        }
        .listStyle(.plain)
        .refreshable { // Pull-to-refresh triggers fetch in manager
             print("ImageListContentView: Refresh triggered.")
             imageDataManager.prepareImageData()
         }
        // MARK: <<< MODIFIED START >>>
        // Use standard overlay modifier with bottom alignment
        .overlay(alignment: .bottom) {
             // Use the extracted overlay view and pass state values
             ProgressIndicatorOverlay(
                 isLoadingList: imageDataManager.isLoadingList,
                 isPreloading: imageDataManager.isPreloading,
                 preloadingProgress: imageDataManager.preloadingProgress,
                 hasImages: !imageDataManager.images.isEmpty // Pass whether images exist
             )
        }
        // MARK: <<< MODIFIED END >>>
        // Moved Nav Title and Toolbar here
        .navigationTitle("My Images")
        .toolbar {
             ToolbarItem(placement: .navigationBarTrailing) {
                 Button {
                      // Manual refresh button triggers fetch in manager
                      imageDataManager.prepareImageData()
                 } label: {
                      Image(systemName: "arrow.clockwise")
                 }
                 // Disable refresh button only while list is actively loading
                 .disabled(imageDataManager.isLoadingList)
             }
        }
    }
}

--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/ImageListContentView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/ImageRow.swift ---
// MARK: ADDED FILE - Views/ImageList/ImageRow.swift
// File: BrickAI/Views/ImageList/ImageRow.swift
// Row view for the image list, extracted from ImageListView.swift

import SwiftUI

// Row view for the list
struct ImageRow: View {
    let image: ImageData
    // Get ImageDataManager from environment to access cache
    @EnvironmentObject var imageDataManager: ImageDataManager

    var body: some View {
        HStack(spacing: 15) {
            // Check cache first
            let imageUrl = image.processedImageUrl ?? image.originalImageUrl
            let cachedImage = imageDataManager.getImage(for: imageUrl)

            Group { // Use Group to apply frame consistently
                if let loadedImage = cachedImage {
                    // Use cached image directly
                    Image(uiImage: loadedImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill) // Use fill for consistent size
                        // Frame applied below by Group
                        .clipped() // Clip to bounds

                } else {
                    // Fallback to AsyncImage if not cached
                    AsyncImage(url: imageUrl) { phase in
                        switch phase {
                        case .empty:
                            ZStack { // Add background during loading
                                Color(.systemGray5)
                                ProgressView()
                            }
                            // Frame applied by Group

                        case .success(let loadedImage):
                            loadedImage
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                // Frame applied by Group
                                .clipped()

                        case .failure:
                            ZStack { // Add background on failure
                                Color(.systemGray5)
                                Image(systemName: "photo.fill")
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .padding(8) // Add padding to the SF Symbol
                                    .foregroundColor(.secondary)
                            }
                            // Frame applied by Group

                        @unknown default:
                            EmptyView()
                        }
                    }
                     // Trigger explicit cache load if image wasn't preloaded
                     .onAppear {
                          imageDataManager.ensureImageIsCached(for: imageUrl)
                     }
                }
            }
            .frame(width: 60, height: 60) // Apply frame here
            .cornerRadius(8) // Apply cornerRadius here
             .background(Color(.systemGray6)) // Add background for consistency


            VStack(alignment: .leading, spacing: 4) { // Added spacing
                Text("Status: \(image.status.capitalized)")
                    .font(.headline)
                    .foregroundColor(statusColor(status: image.status))
                if let prompt = image.prompt, !prompt.isEmpty {
                     Text(prompt) // Removed "Prompt:" prefix for cleaner look
                         .font(.subheadline)
                         .foregroundColor(.secondary)
                         .lineLimit(1)
                         .truncationMode(.tail) // Ensure truncation is clear
                }
                 // Convert Date to String using formatted API for relative style
                 Text(image.createdAt, style: .relative)
                    .font(.caption)
                    .foregroundColor(.gray)
            }

            Spacer() // Push content to left
        }
        .padding(.vertical, 8) // Increased vertical padding for better spacing
    }

    // Helper to determine status color
    private func statusColor(status: String) -> Color {
        switch status.uppercased() {
        case "UPLOADED", "PROCESSING": return .orange
        case "COMPLETED": return .green
        case "FAILED": return .red
        default: return .primary
        }
    }
}
// MARK: END ADDED FILE - Views/ImageList/ImageRow.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/ImageRow.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageList/LoadingView.swift ---
// MARK: ADDED FILE - Views/ImageList/LoadingView.swift
// File: BrickAI/Views/ImageList/LoadingView.swift
// Simple view for the initial loading state

import SwiftUI

struct LoadingView: View {
    var body: some View {
        ProgressView("Loading Images...")
            .frame(maxWidth: .infinity, maxHeight: .infinity) // Center it
    }
}

struct LoadingView_Previews: PreviewProvider {
    static var previews: some View {
        LoadingView()
    }
}
// MARK: END ADDED FILE - Views/ImageList/LoadingView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageList/LoadingView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/ImageListView.swift ---
// MARK: MODIFIED FILE - Views/ImageListView.swift
// File: BrickAI/Views/ImageListView.swift
// Removed Nav Title/Toolbar which were moved to ImageListContentView.

import SwiftUI

struct ImageListView: View {
    // Observe the ImageDataManager directly from the environment
    @EnvironmentObject var imageDataManager: ImageDataManager
    // Access user manager for potential logout action from alert
    @EnvironmentObject var userManager: UserManager
    // State to manage alert presentation based on ImageDataManager's error
    @State private var showErrorAlert = false

    var body: some View {
        // Apply alert and onChange modifiers directly to NavigationView
        NavigationView {
            // Use a Group to switch between the extracted subviews
            Group {
                if imageDataManager.isLoadingList && imageDataManager.images.isEmpty {
                    // Show initial loading view
                    LoadingView()
                } else if imageDataManager.images.isEmpty && imageDataManager.listError == nil && !imageDataManager.isLoadingList {
                    // Show empty state view
                    EmptyListView()
                } else {
                    // Show the main list content view
                    // Pass down environment objects if needed by sub-components (like ImageRow)
                    ImageListContentView()
                        .environmentObject(imageDataManager)
                        // .environmentObject(userManager) // Only if needed by ImageListContentView/ImageRow
                }
            }
            // MARK: <<< MODIFIED START >>>
            // Removed Nav Title and Toolbar from here - they are now in ImageListContentView
            // .navigationTitle("My Images") // MOVED
            // .toolbar { ... } // MOVED
            // MARK: <<< MODIFIED END >>>

        } // End NavigationView
        // --- Error Handling Alert & onChange remain attached to NavigationView ---
        .onChange(of: imageDataManager.listError) { _, newError in
            showErrorAlert = (newError != nil)
        }
        .alert("Error Loading Images", isPresented: $showErrorAlert, presenting: imageDataManager.listError) { error in
            Button("Retry") {
                imageDataManager.prepareImageData()
            }
            if case .sessionExpired = error {
                Button("Log Out", role: .destructive) {
                    // Note: Actual logout + cache clear should happen in SettingsView ideally
                     userManager.clearUser()
                }
            } else if case .authenticationTokenMissing = error {
                 Button("Log Out", role: .destructive) {
                     userManager.clearUser()
                 }
            } else {
                 Button("OK", role: .cancel) { }
            }
        } message: { error in
            Text(error.localizedDescription ?? "An unknown error occurred.")
        }
        // --- End Error Handling Alert & onChange ---
        // Previews (kept as requested)
    }
}

// MARK: END MODIFIED FILE - Views/ImageListView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/ImageListView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/LoginView.swift ---
// MARK: MODIFIED FILE - Views/LoginView.swift
// File: BrickAI/Views/LoginView.swift
// Added trigger for ImageDataManager

import SwiftUI
import AuthenticationServices

struct LoginView: View {
    @EnvironmentObject var userManager: UserManager
    // MARK: <<< ADDED START >>>
    // Inject ImageDataManager from environment
    @EnvironmentObject var imageDataManager: ImageDataManager
    // MARK: <<< ADDED END >>>

    @State private var loginError: String? = nil
    @State private var isAuthenticating: Bool = false

    var body: some View {
        VStack {
            if userManager.isLoggedIn {
                 HomeView()
                     .transition(.opacity.combined(with: .scale))
                     // Pass environment objects down if needed by HomeView or its children
                     // Note: HomeView itself might not need them directly, but its destinations (Settings, ImageList) will
                     .environmentObject(userManager)
                     .environmentObject(imageDataManager) // Pass down imageDataManager
            } else {
                 // --- Login UI (No changes within this part) ---
                 Spacer()
                 Text("Welcome to BrickAI").font(.largeTitle).padding(.bottom, 40)
                 if let errorMsg = loginError { Text(errorMsg).foregroundColor(.red).padding(.horizontal).multilineTextAlignment(.center).transition(.opacity).padding(.bottom) }
                 if isAuthenticating { ProgressView("Authenticating...").padding().transition(.opacity)
                 } else {
                     SignInWithAppleButton(.signIn, onRequest: { request in request.requestedScopes = [.fullName, .email] }, onCompletion: { result in
                         isAuthenticating = true; loginError = nil
                         switch result {
                         case .success(let authResults):
                             // ... (existing credential handling logic) ...
                             guard let appleIDCredential = authResults.credential as? ASAuthorizationAppleIDCredential else { handleLoginError("Failed to process Apple credentials."); return }
                             let appleUserID = appleIDCredential.user
                             var currentUserName: String? = nil
                             if let fullName = appleIDCredential.fullName, let given = fullName.givenName, let family = fullName.familyName { let name = "\(given) \(family)".trimmingCharacters(in: .whitespacesAndNewlines); if !name.isEmpty { currentUserName = name } }
                             if currentUserName == nil { currentUserName = KeychainService.loadString(forKey: kKeychainAccountUserName) ?? "User \(appleUserID.prefix(4))" }
                             guard let authCodeData = appleIDCredential.authorizationCode, let authCode = String(data: authCodeData, encoding: .utf8) else { handleLoginError("Could not retrieve authorization code from Apple."); return }

                             NetworkManager.exchangeAuthCode(authorizationCode: authCode) { exchangeResult in
                                 switch exchangeResult {
                                 case .success(let sessionToken):
                                     // Save credentials (UserManager updates isLoggedIn internally)
                                     userManager.saveCredentials(userName: currentUserName, userIdentifier: appleUserID, sessionToken: sessionToken)
                                     // Login state is updated by userManager, onChange below will trigger image fetch
                                     isAuthenticating = false
                                 case .failure(let error):
                                     handleLoginError(error.localizedDescription)
                                 }
                             }
                         case .failure(let error):
                             if (error as? ASAuthorizationError)?.code == .canceled { isAuthenticating = false; loginError = nil }
                             else { handleLoginError("Sign in with Apple failed: \(error.localizedDescription)") }
                         }
                     })
                     .signInWithAppleButtonStyle(.black).frame(width: 280, height: 45).padding().disabled(isAuthenticating).transition(.opacity.combined(with: .scale(scale: 0.9)))
                 }
                 Spacer()
                 // --- End Login UI ---
            }
        }
        .animation(.default, value: userManager.isLoggedIn)
        .animation(.easeInOut, value: loginError)
        .animation(.easeInOut, value: isAuthenticating)
        // MARK: <<< ADDED START >>>
        // Trigger image data preparation when login state changes or on initial appearance if already logged in
        .onChange(of: userManager.isLoggedIn) { _, newValue in
            if newValue {
                print("LoginView: User logged in (onChange). Preparing image data.")
                imageDataManager.prepareImageData()
            }
            // No action needed if newValue is false (logout handled elsewhere)
        }
        .onAppear {
             // Check if already logged in when the view appears
             if userManager.isLoggedIn {
                  print("LoginView: Already logged in (onAppear). Preparing image data.")
                  imageDataManager.prepareImageData()
             }
        }
        // MARK: <<< ADDED END >>>
    }

    private func handleLoginError(_ message: String) {
         DispatchQueue.main.async {
              self.loginError = message
              self.isAuthenticating = false
         }
    }
}

// Previews (kept as requested)
struct LoginView_Previews: PreviewProvider {
    static var previews: some View {
        // Create mock managers for preview if needed
        let mockUserManager = UserManager.shared // Use singleton or create specific mock
        let mockImageDataManager = ImageDataManager() // Use initializer or create specific mock

        LoginView()
            .environmentObject(mockUserManager)
            .environmentObject(mockImageDataManager)
    }
}
// MARK: END MODIFIED FILE - Views/LoginView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/LoginView.swift ---


--- File Start: ios-app/BrickAI/BrickAI/Views/SettingsView.swift ---
// MARK: MODIFIED FILE - Views/SettingsView.swift
// Updated to clear ImageDataManager cache on logout

import SwiftUI

struct SettingsView: View {
     @EnvironmentObject var userManager: UserManager
     // MARK: <<< ADDED START >>>
     // Inject ImageDataManager to clear cache
     @EnvironmentObject var imageDataManager: ImageDataManager
     // MARK: <<< ADDED END >>>

     var body: some View {
          Form {
              Section("Account") {
                   Text("Username: \(userManager.userName ?? "N/A")")
                   Text("User ID: \(userManager.userIdentifier ?? "N/A")")
                   Button("Log Out", role: .destructive) {
                        // MARK: <<< MODIFIED START >>>
                        // Clear image cache BEFORE clearing user credentials
                        print("SettingsView: Logging out. Clearing image cache.")
                        imageDataManager.clearCache()
                        // Then clear user session
                        userManager.clearUser()
                        // MARK: <<< MODIFIED END >>>
                   }
              }
              // Add other settings sections...
          }
          .navigationTitle("Settings")
     }
}

// Previews (kept as requested)
struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        let mockUserManager = UserManager.shared
        let mockImageDataManager = ImageDataManager()
        NavigationView { // Add NavigationView for preview context
            SettingsView()
                .environmentObject(mockUserManager)
                .environmentObject(mockImageDataManager)
        }
    }
}
// MARK: END MODIFIED FILE - Views/SettingsView.swift
--- File End: ios-app/BrickAI/BrickAI/Views/SettingsView.swift ---


